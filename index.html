<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>guide</title>
<link rel="stylesheet" href="docs/base.css">
<style>
    h1{font-size:48px;margin:0.7em 0;}
    h2{font-weight:500;}
    body{font-size:14px;}
    pre{color: #ccd645; background-color: #1d1d1d;}
    blockquote{border-radius: 8px;}
    blockquote>p{font-size:16px;}
    .btn-shortcut{display:block;padding:10px 12px 10px 14px;text-indent:0;line-height:1;font-size:12px;color:#fff;background-color:transparent;border-bottom: 1px solid rgba(255, 255, 255, 0.1);transition:all 0.35s cubic-bezier(0.22, 0.61, 0.36, 1);}
    .btn-shortcut:hover, .btn-shortcut.active{padding:18px 12px;text-indent:3px;text-decoration: none;color:#333;background-color:#fff;box-shadow:inset 0 -3px 10px 0 rgba(0, 0, 0, 0.12);border-bottom: 0;}
    .btn-top{z-index: 20;position:fixed;bottom:46px;right:50%;margin-right:-45%;}
    .btn-top>a{display:block;width:66px; height:66px;background-color:#fff;border-radius: 50%; border: 1px solid #dedede;} 
    .btn-top>a:hover{text-decoration: none;}
    .btn-top>a:before{content:'↑';padding:0 13px;font-size:39px;color:#337ab7;line-height:62px;}
    .aver-table{width: 100%;margin-top:100px;text-align:center;border-top:2px solid #dedede;}
    .aver-table th{text-align:center;}
    .blind{  visibility: hidden; position: absolute; font-size: 0; width: 0; height: 0; line-height: 0;}
    .container{margin:0 0 180px 230px;}
    .side-bar{position:fixed;left:0;top:0;width:220px;height:100vh;overflow-y:scroll;color: #fff;background:linear-gradient(137deg,#373737,#2f4dc9);}
    .side-bar>.tit{margin-top: 74px; padding: 0 12px; font-size: 18px;}
    .m-bar{display: none;}
    @media (max-width:840px) {
        h1{margin:2em 0 0.5em;}
        .nav-bar{
            position: fixed;
            width: 100%;
            left: 0;
            top: 0;
            height: 40px;
        }
        .nav-bar:after{
           content:'';
           position:absolute;
           width:100%;
           height:50px;
           background-color:#333;
        }
        
         .m-bar{
           display: block;
           position:absolute;
           top:10px;
           left:20px;
           width:32px;
           height:32px;
           background:#fff url(./hamburger-svgrepo-com.svg) 50% 50% no-repeat;
           background-size:32px;
           z-index:1;
        }
        .m-bar.active{
           background:#fff url(./clear-svgrepo-com.svg) 50% 50% no-repeat;
           background-size:32px;
        }
       
        .side-bar{transform:translateX(-100%);transition: transform .5s ease-out;}
        .side-bar.active{transform:translateX(0)}
        .container{overflow-x:hidden;overflow-y:auto;width:100%;margin:0 0 180px 0;}
    }
</style>
<script src="./docs/jquery-1.10.2.min.js">//</script>
</head>
<body>
<div id="header"><span class="blind">header</span></div>
<div class="container"><h1 id="coding-컨벤션">Coding 컨벤션</h1>
<h2 id="버전-표기-설명">버전 표기 설명</h2>
<p>ex) 1.7.2 -&gt; Major.Minor.Maintenance(or Build) 을 의미</p>
<ul>
<li>Major Version : 1로 시작해서 전체를 뒤엎을 정도의 큰 변화가 발생했을 때 이 수치를 올린다.</li>
<li>Minor Version : 0으로 시작해서 없던 기능의 추가나 기존 기능의 수정 등의 변화가 발생했을때 이 수치를 올린다.</li>
<li>Build or Maintenance Version : 자잘한 버그나 내부적 코드 보완 등의 변화가 발생했을때 이 수치를 올린다.</li>
<li>3번째 자리가 10이 될때 2번째 자리수가 1 이 된다.</li>
</ul>
<hr>
<h2 id="1-html">1. HTML</h2>
<h3 id="1-1-syntax">1-1. Syntax</h3>
<ul>
<li>들여쓰기는 2개의 공백 문자(소프트탭)을 사용. 다른 규칙으로 통일하여 작성해도 된다.</li>
<li>모든 엘리먼트 명과 애트리뷰트 명은 케밥 표기법(kebab-case)으로 작성.</li>
<li>모든 애트리뷰트 값은 큰 따옴표(“)로 감싸기.</li>
<li>주석 <code>&lt;!--  ---&gt;</code> 처럼 기본 표기 하고 <blockquote>
<p>note : 수정사항 등을 기재하기 위한 주석 ( 주석에 년도날짜 / 수정내용 표기는 반드시 해야 한다 )</p>
</blockquote>
<pre><code>&lt;!-- start: 20200330 수정 및 추가 --&gt; 
&lt;div&gt; ......중략....... &lt;/div&gt;
&lt;!-- end : 20200330 수정 및 추가 --&gt; </code></pre>혹은  <pre><code>&lt;!-- 20200330 수정 및 추가 --&gt;
&lt;div&gt; ......중략....... &lt;/div&gt; 
&lt;!-- // 20200330 수정 및 추가 --&gt;</code></pre></li>
</ul>
<h3 id="1-2-doctype">1-2. Doctype</h3>
<ul>
<li>Doctype 은 HTML5 DTD 로 선언.
<code>&lt;!DOCTYPE html&gt;</code>  html5 로 지정 </li>
</ul>
<p>이어서 자기 마침 태그(Self-Closing Tags)에 후행 슬래시(/)를 사용금지.</p>
<pre><code>&lt;!-- Bad --&gt;
&lt;input /&gt;
&lt;br /&gt;

&lt;!-- Good --&gt;
&lt;input&gt;
&lt;br&gt;</code></pre><h3 id="1-3-metadata">1-3. Metadata</h3>
<p><code>&lt;head&gt;</code>  엘리먼트의 자식 엘리먼트는 아래의 순서대로 작성.</p>
<ol>
<li>Charset</li>
<li>X-UA-Compatible</li>
<li>Viewport</li>
<li>Title</li>
<li>Meta</li>
<li>Style</li>
<li>JavaScript</li>
</ol>
<pre><code>&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no&quot; &gt;
&lt;title&gt;Hello, World!&lt;/title&gt;
&lt;meta content=&quot;&quot; property=&quot;og:title&quot;&gt;
&lt;meta content=&quot;&quot; property=&quot;og:url&quot;&gt;
&lt;meta content=&quot;&quot; property=&quot;og:description&quot;&gt;
&lt;meta content=&quot;&quot; property=&quot;og:image&quot;&gt;
&lt;meta content=&quot;website&quot; property=&quot;og:type&quot;&gt;
&lt;meta content=&quot;&quot; property=&quot;og:site_name&quot;&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;foo.css&quot;&gt;
&lt;script src=&quot;bar.js&quot;&gt;&lt;/script&gt;</code></pre><p>A. Charset
문서의 언어셋은 UTF-8으로 선언. </p>
<pre><code>&lt;meta charset=&quot;utf-8&quot;&gt;</code></pre><p>B. X-UA-Compatible
PC용 웹사이트는 최신 버전의 IE로 렌더링하기 위해 문서모드를 Edge로 선언.</p>
<pre><code>&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge&quot;&gt;</code></pre><p>C.Viewport
모바일 기기에서 실제 렌더링되는 영역과 뷰포트의 크기를 조절. 또한 줌 레벨도 조정 가능.</p>
<pre><code>&lt;meta content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no&quot; name=&quot;viewport&quot;&gt;</code></pre><ul>
<li>width=device-width : 페이지의 너비를 기기의 스크린 너비로 설정합니다. 즉, 렌더링 영역을 기기의 뷰포트의 크기와 같게 만들어 준다.</li>
<li>initial-scale=1.0 : 처음 페이지 로딩시 확대/축소가 되지 않은 원래 크기를 사용하도록 합니다. 0~10 사이의 값을 가진다.</li>
<li>minimum-scale : 줄일 수 있는 최소 크기를 지정. 0~10 사이의 값을 가진다.</li>
<li>maximum-scale : 늘릴 수 있는 최대 크기를 지정. 0~10 사이의 값을 가진다.</li>
<li>user-scalable : yes 또는 no 값을 가지며 사용자가 화면을 확대/축소  지정.</li>
</ul>
<p>위의 줌 레벨은 1이 원래크기이고, 0.5 라면 50% 축소를 뜻한다.</p>
<h3 id="1-4-elements">1-4. Elements</h3>
<p>a. 스타일 제어가 어려운 엘리먼트
  자식 엘리먼트 태그가 한정적이거나(ex. <code>&lt;table&gt;</code>) 스타일 제어에 한계를 가진 엘리먼트(ex. <code>&lt;select&gt;</code>)가 컴포넌트의 루트 역할로 쓰일 땐 
  나중에 발생할 유지보수를 고려해 <code>&lt;div&gt;</code>나 <code>&lt;span&gt;</code> 엘리먼트로 감싸는 것을 추천.</p>
<pre><code>&lt;!-- Not Bad --&gt;
&lt;table class=&quot;table&quot;&gt;&lt;/table&gt;
&lt;select class=&quot;combobox&quot;&gt;&lt;/select&gt;

&lt;!-- Good --&gt;
&lt;div class=&quot;table&quot;&gt;
  &lt;table&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;span class=&quot;combobox&quot;&gt;
  &lt;select&gt;&lt;/select&gt;
&lt;/span&gt;</code></pre><p>b. 테이블 제목</p>
<ul>
<li><code>&lt;caption&gt;</code> 엘리먼트의 뷰를 숨길 때는 새로운 엘리먼트로 감싸서 숨긴다..  <code>&lt;caption&gt;</code>을 바로 숨긴다면 브라우저에 따라 스타일이 깨질 수도 있다. 
테이블의 제목이 필요없거나 이미 제공되었다면 생략. 컨텐츠를 중복 제공 X </li>
</ul>
<pre><code>&lt;!-- Bad --&gt;
&lt;table&gt;
  &lt;caption class=&quot;blind&quot;&gt;My Caption&lt;/caption&gt;
&lt;/table&gt;

&lt;!-- Good --&gt;
&lt;table&gt;
  &lt;caption&gt;
    &lt;div class=&quot;blind&quot;&gt;My Caption&lt;/div&gt;
  &lt;/caption&gt;
&lt;/table&gt;</code></pre><p>c. 입력 필드
회원가입 폼의 입력 필드처럼 너비, 높이가 유동적이라면 인라인 스타일로 제어. 이렇게 하면 불필요한 클래스 생성을 막을 수 있다.</p>
<pre><code>&lt;!-- Bad --&gt;
&lt;input type=&quot;text&quot; class=&quot;input input--width-120&quot;&gt;
&lt;input type=&quot;text&quot; class=&quot;input input--width-180&quot;&gt;

&lt;!-- Good --&gt;
&lt;input type=&quot;text&quot; class=&quot;input&quot; style=&quot;width:120px&quot;&gt;
&lt;input type=&quot;text&quot; class=&quot;input&quot; style=&quot;width:180px&quot;&gt;</code></pre><h3 id="1-5-attributes">1-5. Attributes</h3>
<ul>
<li>애트리뷰트는 변하지 않는 것부터 먼저 선언. 애트리뷰트의 순서가 비슷한 엘리먼트끼리 통일되므로 검색하기 좋다.</li>
<li>id는 하나의 페이지 안에서 이름이 유일해야하고, name 은 중복될 수 있다.<br>따라서 따로따로 접근할 때는 id 값을 이용하고, 그룹으로 접근하고 할 때는  name 을 활용하는 식으로 편의성을 가질 수 있다. 
하지만 대체적으로 ajax 통신을 직접하지 않고 마크업 기준으로만 작업한다면 id만 쓰는 것을 추천. 다수 선택은 class 로 사용하길~~
(  name은 주로 form 요소로써 서버와 통신하는 목적으로 주 사용. )</li>
</ul>
<pre><code>&lt;input class=&quot;input&quot; type=&quot;text&quot; id=&quot;userId&quot; name=&quot;userId&quot; title=&quot;아이디&quot; style=&quot;width:100px&quot;&gt;
&lt;input class=&quot;input&quot; type=&quot;password&quot; id=&quot;userPw&quot; name=&quot;userPw&quot; title=&quot;비밀번호&quot; style=&quot;width:120px&quot;&gt;</code></pre><p>a. Boolean 애트리뷰트</p>
<ul>
<li>HTML5에서는 Boolean 애트리뷰트를 선언하는 것 만으로도 true 값을 가진다. 필요하지 않다면 값을 작성 하지 않는게 좋다.</li>
</ul>
<pre><code>&lt;!-- Not Bad --&gt;
&lt;button disabled=&quot;true&quot;&gt;&lt;/button&gt;

&lt;!-- Good --&gt;
&lt;button disabled&gt;&lt;/button&gt;</code></pre><p>c. name 애트리뷰트</p>
<ul>
<li>name 애트리뷰트 값은 비즈니스 로직을 작성하는 언어의 네이밍 규칙에 맞게 작성(캐멀케이스로 작성)하는 것을 권장.</li>
<li>name 이 없을시는 id 값을 캐멀케이스로 작성.<pre><code>&lt;!-- camelCase --&gt;
&lt;form class=&quot;form-group&quot; id=&quot;myForm&quot; name=&quot;myForm&quot;&gt;
&lt;input class=&quot;input&quot; type=&quot;text&quot; id=&quot;myUserName&quot; name=&quot;myUserName&quot;&gt;
&lt;/form&gt;</code></pre></li>
</ul>
<h3 id="1-6-import">1-6. Import</h3>
<ul>
<li>HTML5 에서 CSS 와 JS 파일을 불러올 때 type 애트리뷰트는 이미 기본값을 가진다. 필요하지 않다면 선언 X.
<code>&lt;script&gt;</code>엘리먼트는 가급적 <code>&lt;head&gt;</code> 또는 <code>&lt;body&gt;</code> 엘리먼트의 가장 마지막에 작성. 
( 웹브라우저는 <code>&lt;script&gt;</code> 엘리먼트를 만나면 처리가 끝날 때까지 HTML 파싱을 멈춘다. )</li>
</ul>
<pre><code>&lt;!-- bad  --&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    // Javascript code
&lt;/script&gt;

&lt;!-- good --&gt;
&lt;script&gt;
    // Javascript code
&lt;/script&gt;</code></pre><ul>
<li><code>&lt;head&gt;&lt;/head&gt;</code>태그 내에 로드 순서 지키기( CSS 태그를 자바스크립트 태그 앞에 두기 )</li>
<li>자바스크립트 전에 CSS 태그를 두면 브라우저의 렌더링 속도를 높이는 병렬 다운로드가 가능해 진다.</li>
</ul>
<pre><code>&lt;!-- Not recommended --&gt;
&lt;script src=&quot;jquery.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;foo.js&quot;&gt;&lt;/script&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;foo.css&quot;/&gt;

&lt;!-- Recommended --&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;foo.css&quot;/&gt;
&lt;script src=&quot;jquery.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;foo.js&quot;&gt;&lt;/script&gt;</code></pre><h2 id="2-css">2. CSS</h2>
<blockquote>
<p>note: CSS 코드의 작성 및 규칙사항</p>
<ul>
<li>CSS 파일을 압축하고, 최종 파일에서 주석, 공백, 줄바꿈을 제거한다. ( 유지 보수 및 수정 사항 전달 등에 있어서 주석 처리 예외 )</li>
<li>CSS 파일을 압축하면 클라이언트에게 더 적은 데이터를 전송하게 되며, 콘텐츠가 더 빨리 로드. </li>
<li>CSS 파일을 압축하는 것은 중요한 이유는 대역폭과 리소스 사용을 줄이고자 하는 모든 부분에 있어서 도움이 된다.</li>
</ul>
</blockquote>
<h3 id="preload">preload</h3>
<ul>
<li>preload 를 통해 브라우저가 페이지의 콘텐츠를 보여지기 전에 CSS 파일을 로드할 수 있다.</li>
<li>rel 속성의 값을 preload 로 주고, as=”style” 를 <code>&lt;link&gt;</code> 태그에 넣는다.</li>
<li>참고 URL : <a href="https://developers.google.com/web/fundamentals/performance/resource-prioritization?hl=ko">리소스 우선순위 지정</a></li>
</ul>
<pre><code>&lt;link rel=&quot;preload&quot; href=&quot;style.min.css&quot; as=&quot;style&quot; onload=&quot;this.rel=&#39;stylesheet&#39;&quot;&gt;</code></pre><h3 id="2-1-syntax">2-1. Syntax</h3>
<ul>
<li>Lint 의 사용을 권장!</li>
<li>css class 이름은 케밥 표기법 ( kebab-case )으로 작성. 알파벳(대소문자)로 시작하되 숫자/특수문자로 시작하여선 안된다.</li>
<li>css id 는 캐멀 케이스 ( Camel case )방식으로 이름을 명기한다.</li>
<li>들여쓰기는 2개의 공백 문자(소프트탭)을 사용. 다른 규칙으로 통일하여 작성해도 된다.</li>
<li>프로퍼티는 되도록 한 줄에 하나씩 작성. </li>
<li>프로퍼티는 영문 소문자로 작성.</li>
<li>일반적으로 작은 따옴표(‘)를 사용하지만 @charset 선언과 타입 선택자는 큰 따옴표(“)를 사용. 가능하다면 생략하는 것이 가장 좋다.</li>
<li>사용되지 않는 CSS 선택자는 제거</li>
</ul>
<h3 id="2-2-charset">2-2. Charset</h3>
<ul>
<li>문서의 언어셋은 UTF-8으로 최상위에 선언. </li>
<li>언어셋이 정해진 번들링 파일이라면 선언하지 않는다.</li>
</ul>
<pre><code>@charset &quot;UTF-8&quot;;</code></pre><h3 id="2-3-selectors">2-3. Selectors</h3>
<ul>
<li>태그이름과 선택자는 가급적 중첩하지 않는다. </li>
<li>Indentation Depth 는 3 Depth 까지, 가급적 1 Depth 만을 사용하는 것을 권장한다.</li>
</ul>
<h3 id="2-4-z-index">2-4. z-index</h3>
<ul>
<li>z-index 스택을 0부터 규칙 없이 쌓는다면 순서가 꼬인다. 엘리먼트의 특성에 맞게 계층을 분리하여 체계적으로 관리하는 것이 좋은 방법.</li>
<li>CSS 전처리기의 믹스인을 활용한다면 간편하게 작성할 수 있다.</li>
</ul>
<pre><code>/* scss */
.foo {
  position: absolute;
  @include layer-index(&#39;floating&#39;, 3000);
}

/* css */
.foo {
  z-index: 16203000
}</code></pre><h3 id="2-5-import">2-5. Import</h3>
<p>CSS 의 기본 문법인 @import 는 성능 문제를 가지고 있다. 사용 X.</p>
<ul>
<li>여러개의 <code>&lt;link&gt;</code> 엘리먼트로 작성하기</li>
<li>하나의 CSS 파일로 작성하기<ul>
<li>CSS 전처리기의 @import 문법을 사용하기</li>
<li>번들러 등의 도구를 이용하여 하나의 CSS 파일로 병합하기</li>
</ul>
</li>
</ul>
<pre><code>  &lt;!-- Too Bad --&gt;
  &lt;style&gt;
    @import url(&quot;one.css&quot;);
    @import url(&quot;two.css&quot;);
    @import url(&quot;three.css&quot;);
  &lt;/style&gt;

  &lt;!-- Good --&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;one.css&quot;&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;two.css&quot;&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;three.css&quot;&gt;

  &lt;!-- Very Nice --&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;bundle.css&quot;&gt; &lt;!-- one.css, .. in bundle.css --&gt;</code></pre><h3 id="2-6-media-query">2-6. Media Query</h3>
<ul>
<li>미디어 쿼리는 컴포넌트 단위로 분류하여 관련 규칙 바로 뒤에 작성.
혹은 문서의 마지막에 모아서 작성.</li>
</ul>
<pre><code>.foo-a {}
.foo-b {}
@media (min-width: 768px) {
  .foo-a {}
  .foo-b {}
}

.bar {}
.foo-a {}
.foo-b {}

.bar {}

@media (min-width: 768px) {
  .foo-a {}
  .foo-b {}
}</code></pre><h3 id="2-7-nesting중첩">2-7. Nesting(중첩)</h3>
<ul>
<li>너무 많은 선택자의 중첩은 피해야 하므로, CSS 전처리기가 지원하는 Nesting 문법은 주의해서 사용해야 한다!</li>
</ul>
<pre><code>/* Bad */
.foo {
  .bar {
    color: #abc;
  }
}

/* Good */
.foo__bar {
  color: #abc;
}</code></pre><h3 id="2-8-extend">2-8. Extend</h3>
<ul>
<li>CSS 전처리기가 지원하는 Extend 문법은  사용하지 X.  Mixin 으로 대체!</li>
</ul>
<h3 id="2-9-reset">2-9. Reset</h3>
<ul>
<li>초기화 스타일은 서비스에 맞게 정의. 만약 normalize.css 또는 Bootstrap 등의 프레임워크를 사용한다면 초기화를 생략.</li>
</ul>
<h3 id="2-10-vendor-prefix">2-10. Vendor Prefix</h3>
<ul>
<li>벤더 프리픽스 프로퍼티는 일반 프로퍼티보다 먼저 선언.</li>
</ul>
<pre><code>/* Bad */
.foo {
  box-shadow: 0 1px 2px rgba(0, 0, 0, .15);
  -webkit-box-shadow: 0 1px 2px rgba(0, 0, 0, .15);
}
/* Good */
.foo {
  -webkit-box-shadow: 0 1px 2px rgba(0, 0, 0, .15);
  box-shadow: 0 1px 2px rgba(0, 0, 0, .15);
}</code></pre><h3 id="2-11-naming">2-11. Naming</h3>
<ul>
<li>접두사가 2개 이상 중복 시 기능적인 접두사가 맨 앞부분에 위치할 수 있도록 한다.</li>
<li>단독사용 클래스는 지양하며 접두사를 조합한 형태로 작성한다.</li>
<li>on 클래스인 경우, 단일 특정요소에 상태변화 클래스를 적용한다면 접미사로서 적용한다.</li>
</ul>
<table>
<thead>
<tr>
<th align="left">ClassName</th>
<th></th>
<th>Description</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">wrap / cnt</td>
<td></td>
<td>일반 영역의 묶음 - ex) btn-cnt / btn-wrap</td>
<td></td>
</tr>
<tr>
<td align="left">group</td>
<td></td>
<td>같은 엘리먼트 묶음 - ex) btn 3개를 묶는 경우 <code>&lt;div class=&quot;btn-group&quot;&gt;&lt;button class=&quot;btn&quot;&gt;버튼&lt;/button&gt;&lt;button class=&quot;btn&quot;&gt;버튼&lt;/button&gt;&lt;button class=&quot;btn&quot;&gt;버튼&lt;/button&gt;&lt;/div&gt;</code></td>
<td></td>
</tr>
<tr>
<td align="left">inner</td>
<td></td>
<td>부모 wrapper 가 존재하며 자식 묶음이 단독으로 사이즈가 필요한 경우</td>
<td></td>
</tr>
<tr>
<td align="left">img-cnt</td>
<td></td>
<td>이미지를 감싸는 경우</td>
<td></td>
</tr>
<tr>
<td align="left">txt-cnt</td>
<td></td>
<td>텍스트를 감싸는 경우</td>
<td></td>
</tr>
<tr>
<td align="left">m-tit</td>
<td></td>
<td>메인페이지 타이틀(중) 텍스트</td>
<td></td>
</tr>
<tr>
<td align="left">s-tit</td>
<td></td>
<td>메인페이지 타이틀(소) 텍스트</td>
<td></td>
</tr>
<tr>
<td align="left">tit-sub</td>
<td></td>
<td>서브페이지 타이틀(대) 텍스트</td>
<td></td>
</tr>
<tr>
<td align="left">m-tit-sub</td>
<td></td>
<td>서브페이지 타이틀(중) 텍스트</td>
<td></td>
</tr>
<tr>
<td align="left">s-tit-sub</td>
<td></td>
<td>서브페이지 타이틀(소) 텍스트</td>
<td></td>
</tr>
<tr>
<td align="left">tit</td>
<td></td>
<td>타이틀 텍스트</td>
<td></td>
</tr>
<tr>
<td align="left">desc</td>
<td></td>
<td>상세 내용</td>
<td></td>
</tr>
<tr>
<td align="left">txt-date</td>
<td></td>
<td>날짜</td>
<td></td>
</tr>
<tr>
<td align="left">btn-cnt</td>
<td></td>
<td>버튼을 감싸는 경우</td>
<td></td>
</tr>
<tr>
<td align="left">list-cnt</td>
<td></td>
<td>리스트를 감싸는 경우(ul)</td>
<td></td>
</tr>
<tr>
<td align="left">tab</td>
<td></td>
<td>탭 메뉴</td>
<td></td>
</tr>
</tbody></table>
<h3 id="2-12-유용한-tip">2-12. 유용한 tip</h3>
<pre><code>html {
-webkit-touch-callout:none;
-webkit-user-select:none;
-webkit-tap-highlight-color:rgba(0, 0, 0, 0);
}</code></pre><ul>
<li><code>webkit-touch-callout</code> 는 아이폰에서만 적용된다. 롱프레스시 새로운탭에서 열기, 읽기목록 추가, 복사하기, 공유 등 하단에 나오는 ios 네이티브 메뉴바 설정. none 으로 할 때 나오지 않게 됨.</li>
<li><code>webkit-user-select</code> 는 모바일웹에서 엘리먼트 드래그 방지용. 특히 텍스트 같은 경우 드래그 해서 선택 방지시에 많이 사용.</li>
<li><code>webkit-tap-highlight-color</code> 는 롱프레스시에 해당 엘리먼트가 파랗게 선택되어 보여지는 것을 방지.</li>
</ul>
<hr>
<h2 id="3-scss">3. SCSS</h2>
<blockquote>
<p>note :</p>
<ul>
<li>중첩( Nesting )은 웬만하면 4depth 이하로 작성.</li>
<li>import : 공통 파일을 기능 별로 나누어 _(언더스코어) 붙여서 분할된 파일( partial ) 로 구성한다. ( 컴파일시엔 merge 되어 파일 하나로 볼 수 있다. )</li>
<li>extend : 되도록이면 mixin 으로 사용하는 게 좋다.</li>
<li>함수 : 자주 사용하는 계산 값에 대해 사용.</li>
</ul>
</blockquote>
<ol>
<li>기능 별 분리</li>
</ol>
<ul>
<li>_component.scss 의 경우 공통 컴포넌트의 집합체이기에 많은 수의 컴포넌트가 존재한다.
기능 별로 분리할 필요가 있다. 대표적으로 _variable(공통 변수), _button, _input, _form</li>
</ul>
<h3 id="3-1-variables-변수">3-1. Variables (변수)</h3>
<ul>
<li>sass에서 변수라는 기능을 제공하는 이유는 재사용성을 위함이다. 변수로 등록된 스타일은 쉽게 다른 코드에서 사용할 수 있기 때문이다.</li>
</ul>
<pre><code>
    $font-stack : Helvetical, sans-serif;
    $primary-color : #333;


    body{
        font : 100% &amp;font-stack;
        color: $primary-color;
    }
</code></pre><h3 id="3-2-nesting-중첩">3-2. Nesting (중첩)</h3>
<ul>
<li>부모 요소를 반복적으로 작성하던 불편함을 해결한다.</li>
<li>대부분의 스타일 가이드는 최대 깊이를 4로 설정. 가급적 4depth 이내의 중첩 구조를 갖도록 하는 것이 좋다.</li>
</ul>
<h3 id="3-3-partials-파일분할">3-3. Partials (파일분할)</h3>
<ul>
<li>공식문서에 따르면, scss의 파일 구조를 모듈화 할 수 있다. 하지만, 아까 처음 명령어를 통해서 모듈화된 코드가 있다고 가정했을 때 이를 나누어 모듈화 시킬 scss를 제외하고 scss만 컴파일 하기에는 상당히 고생할 수도 있다. 
따라서 <strong>*   _partial.scss 처럼 파일 명 앞에 언더 스코어 바를 통해서 빌드에서 제외 시킬 수 있다.   *</strong></li>
</ul>
<h3 id="3-4-mixins-재활용">3-4. Mixins (재활용)</h3>
<ul>
<li>믹스 인을 통해서, 사이트 전체에서 재사용할 CSS declarations를 만들 수 있다. 또한, 값들을 믹스인을 통해서 집어 넣을 수 있으며(파라미터), 이를 통해서 좀더 유연하고 동적인 CSS 구조를 만들 수 있다.</li>
</ul>
<pre><code>/* _mixin.scss */
    @mixin transform($property) {              
        -webkit-transform: $property;
        -ms-transform: $property;
        transform: $property;
    }

/* _ex.scss */
    .box { @include transform(rotate(30deg)); } </code></pre><pre><code>/* _mixin.scss */
    @mixin columnWidth( $selector ){          
        &amp;[data-column=&quot;2&quot;]{
            #{$selector}{width:50%;}
        }
        &amp;[data-column=&quot;3&quot;]{
        #{$selector}{width:33.33333%;}
        }
    }

/* _button.scss */
    .btn-group[data-column]{                 
          width:100%;
          display: flex;
          flex-wrap: wrap;
          @include columnWidth(&#39;.btn&#39;);

         &amp;[data-column=&quot;2&quot;]{
            @include rowChild( 2, &#39;.btn&#39;);
          }
         &amp;[data-column=&quot;3&quot;]{
           @include rowChild( 3, &#39;.btn&#39;);
         }
     }</code></pre><p>믹스인을 만들기 위해 해야 되는 절차는 다음과 같다.</p>
<blockquote>
<ul>
<li>@mixin 지시문을 앞에 사용,</li>
<li>함수의 파라미터처럼 ($변수) 이름 정의</li>
<li>mixin 지시문을 사용하고 이름을 지정</li>
<li>이를 사용할때에는 @include를 통해서 사용할 수 있다. (반응형을 위한 미디어 쿼리 작성 또한 이를 통해서 진행 할 수 있다. )</li>
</ul>
</blockquote>
<h3 id="3-5-function-함수">3-5. Function (함수)</h3>
<ul>
<li>자신의 함수를 정의하여 사용할 수 있다.</li>
<li>함수와 Mixins은 거의 유사하지만 반환되는 내용이 다르다.</li>
<li>Mixin은 지정한 스타일(Style)을 반환하는 반면, 함수는 보통 연산된(Computed) 특정 값을 @return 지시어를 통해 반환한다.</li>
</ul>
<pre><code>
// Mixins
@mixin 믹스인이름($매개변수) {
  스타일;
}

// Functions
@function 함수이름($매개변수) {
  @return 값
}
</code></pre><p>함수는 함수이름으로 바로 사용한다. (Mixin은 @include 지시어를 사용)</p>
<pre><code>
// Mixin
@include 믹스인이름(인수);

// Functions
함수이름(인수)
</code></pre><p>아래 예시와 같이 함수는 @include 같은 별도의 지시어 없이 사용하기 때문에 내가 지정한 함수와 내장 함수(Built-in Functions)의 이름이 충돌할 수 있다. 따라서 내가 지정한 함수에는 별도의 접두어를 붙여주는 것이 좋다.</p>
<pre><code>
// SCSS:

$max-width: 980px;

@function columns($number: 1, $columns: 12) {
  @return $max-width * ($number / $columns)
}

.box_group {
  width: $max-width;

  .box1 {
    width: columns();  // 1
  }
  .box2 {
    width: columns(8);
  }
  .box3 {
    width: columns(3);
  }
}





// Compiled to:

.box_group {
  /* 총 너비 */
  width: 980px;
}
.box_group .box1 {
  /* 총 너비의 약 8.3% */
  width: 81.66667px;
}
.box_group .box2 {
  /* 총 너비의 약 66.7% */
  width: 653.33333px;
}
.box_group .box3 {
  /* 총 너비의 25% */
  width: 245px;
}
</code></pre><p> 예를 들어, 색의 빨강 성분을 가져오는 내장 함수로 이미 red()가 있다면, 접두어를 붙여 extract-red() 같은 이름을 만들 수 있다.</p>
<pre><code>
@function extract-red($color) {
  // 내장 함수
  @return rgb(red($color), 0, 0);
}

div {
  color: extract-red(#D55A93);
}
</code></pre><h3 id="3-6-if-조건문">3-6. If (조건문)</h3>
<p>필요한 경우가 아니라면 괄호 없이 사용 한다.</p>
<pre><code>
&lt;!-- bad --&gt;
@if ($support-legacy == true) {
  // …
}
@else {
  // …
}


&lt;!-- good --&gt;
@if $support-legacy {
  // …
} @else {
  // …
}
</code></pre><p>거짓 값을 테스트 하는 경우에 false, null 대신에 not 키워드를 사용 한다.</p>
<pre><code>
&lt;!-- bad --&gt;
@if index($list, $item) == null {
  // …
}

&lt;!-- good --&gt;
@if not index($list, $item) {
  // …
}
</code></pre><p>언제나 변수 부분을 조건문의 왼쪽에, 기대되는 (혹은 기대되지 않는) 결과를 오른쪽에 배치 한다.</p>
<pre><code>
&lt;!-- bad --&gt;
@if 42 == $value {
  // …
}

&lt;!-- good --&gt;
@if $value == 42 {
  // …
}
</code></pre><p>조건에 따라 다른 결과를 반환하는 함수 안에서 조건문을 사용할 때는, 반드시 함수가 조건문 블록 밖에서도 @return문을 갖도록 해야 한다.</p>
<pre><code>
&lt;!-- bad --&gt;
@function dummy($condition) {
  @if $condition {
    @return true;
  } @else {
    @return false;
  }
}

&lt;!-- good --&gt;
@function dummy($condition) {
  @if $condition {
    @return true;
  }

  @return false;
}
</code></pre><h3 id="3-7-for-반복문">3-7. For (반복문)</h3>
<ul>
<li>@for는 스타일을 반복적으로 출력한다.</li>
<li>변수는 관례상 $i 를 사용한다.</li>
<li>through를 사용하는 형식과 to를 사용하는 형식으로 나뉜다.</li>
</ul>
<pre><code>// SCSS

// through를 사용하는 경우(1부터 3번 이하 반복)
@for $i from 1 through 3 {
  .through:nth-child(#{$i}) {
    width : 20px * $i
  }
}



// Compiled to:

.through:nth-child(1) { width: 20px; }
.through:nth-child(2) { width: 40px; }
.through:nth-child(3) { width: 60px; }

</code></pre><pre><code>// SCSS

// to를 사용하는 경우(1부터 3번 미만, 2번 반복)
@for $i from 1 to 3 {
  .to:nth-child(#{$i}) {
    width : 20px * $i
  }
}



// Compiled to:

.to:nth-child(1) { width: 20px; }
.to:nth-child(2) { width: 40px; }
</code></pre><p>ex)</p>
<pre><code>// SCSS


$total:500;

@for $i from 0 through $total {
  $unit: if($i == 0,  !important, px !important);

  .mgt-#{$i} {
    margin-top:  #{$i}#{$unit};
  }
  .mgb-#{$i} {
    margin-bottom:  #{$i}#{$unit};
  }
}



// Compiled to:

.mgt-0 {
  margin-top: 0!important;
}

.mgb-0 {
  margin-bottom: 0!important;
}

......중략.......


.mgt-500 {
  margin-top: 500px !important;
}

.mgb-500 {
  margin-bottom: 500px !important;
}
</code></pre><hr>
<h2 id="4-javascript">4. Javascript</h2>
<h3 id="1-javascript-naming-convention">1. javascript Naming convention</h3>
<h4 id="일관성을-유지">일관성을 유지</h4>
<pre><code>/* Bad */
const pages_count = 5
const shouldUpdate = true


/* Good */
const pageCount = 5
const shouldUpdate = true


/* Good as well */
const page_count = 5
const should_update = true</code></pre><h4 id="s-i-d-short---intutitive---descriptive-"><strong>S-I-D( Short - Intutitive - Descriptive )</strong></h4>
<p>이름은 짧고 직관적이며 설명적이어야 한다.</p>
<ul>
<li>Short( 짧은 ). 이름을 입력하는 데 시간이 오래 걸리지 않으므로 기억해야 한다.</li>
<li>Intutitive( 직관적 ). 이름은 가능한 한 일반적인 연설에 가깝게 자연스럽게 읽어야 한다.</li>
<li>Descriptive( 설명 ). 이름은 가장 효율적인 방식으로 수행/소유하는 것을 반영해야 한다.</li>
</ul>
<pre><code>/* Bad */
const a = 5 // &quot;a&quot; could mean anything
const isPaginatable = a &gt; 10 // &quot;Paginatable&quot; sounds extremely unnatural
const shouldPaginatize = a &gt; 10 // Made up verbs are so much fun!


/* Good */
const postCount = 5
const hasPagination = postCount &gt; 10
const shouldDisplayPagination = postCount &gt; 10 // alternatively</code></pre><h4 id="축소-방지--avoid-contractions-"><strong>축소 방지 ( Avoid contractions )</strong></h4>
<p>네이밍 축소. 즉 너무 짧게 줄여서 약어처럼 사용하지 않게 하기.</p>
<ul>
<li>코드의 가독성을 떨어뜨리는 것 외에는 아무 것도 기여하지 않는다.</li>
</ul>
<pre><code>/* Bad */
const onItmClk = () =&gt; {}

/* Good */
const onItemClick = () =&gt; {}</code></pre><h4 id="컨텍스트-중복-방지-avoid-context-duplication-"><strong>컨텍스트 중복 방지( Avoid context duplication )</strong></h4>
<ul>
<li>이름은 정의된 컨텍스트와 중복되어서는 안된다. 가독성이 떨어지지 않는다면 항상 이름에서 컨텍스트를 제거.</li>
</ul>
<pre><code>class MenuItem {
  /* 메서드 이름이 컨텍스트(&quot;MenuItem&quot;)와 중복.*/
  handleMenuItemClick = (event) =&gt; { ... }

  /*  `MenuItem.handleClick()` 처럼 쓰는게 훨씬 좋아보인다. */
  handleClick = (event) =&gt; { ... }
}</code></pre><h4 id="예상-결과-반영-reflect-the-expected-result"><strong>예상 결과 반영 (Reflect the expected result)</strong></h4>
<ul>
<li>이름은 예상 결과를 반영해야 합니다.</li>
</ul>
<pre><code>const isEnabled = itemCount &gt; 3
return &lt;Button disabled={!isEnabled} /&gt;

/* Good */
const isDisabled = itemCount &lt;= 3
return &lt;Button disabled={isDisabled} /&gt;</code></pre><p>/* Bad */</p>
<h4 id="naming-functions"><strong>Naming functions</strong></h4>
<ul>
<li>함수의 이름을 지정할 때 따라야 할 유용한 패턴.</li>
</ul>
<p><strong>A/HC/LC Pattern</strong></p>
<ul>
<li>prefix? + action (A) + high context (HC) + low context? (LC)</li>
</ul>
<p>Take a look at how this pattern may be applied in the table below.</p>
<table>
<thead>
<tr>
<th align="left">Name</th>
<th align="left">Prefix</th>
<th align="left">Action (A)</th>
<th align="left">High context (HC)</th>
<th align="left">Low context (LC)</th>
</tr>
</thead>
<tbody><tr>
<td align="left">getPost</td>
<td align="left">—</td>
<td align="left">get</td>
<td align="left">Post</td>
<td align="left">—</td>
</tr>
<tr>
<td align="left">getPostData</td>
<td align="left">—</td>
<td align="left">get</td>
<td align="left">Post</td>
<td align="left">Data</td>
</tr>
<tr>
<td align="left">handleClickOutside</td>
<td align="left">—</td>
<td align="left">handle</td>
<td align="left">Click</td>
<td align="left">Outside</td>
</tr>
<tr>
<td align="left">shouldDisplayMessage</td>
<td align="left">should</td>
<td align="left">Display</td>
<td align="left">Message</td>
<td align="left">—</td>
</tr>
</tbody></table>
<blockquote>
<ul>
<li>Note: 참고: 컨텍스트의 순서는 변수의 의미에 영향을 준다.
예를 들어 shouldUpdateComponent 는 구성 요소를 업데이트하려고 함을 의미.
shouldComponentUpdate 는 구성 요소가 자체적으로 업데이트된다는 것을 알려줍니다. 
업데이트해야 하는 시기를 제어하는 것 뿐이다. 즉, 상위 컨텍스트는 변수의 의미를 강조.</li>
</ul>
</blockquote>
<hr>
<h5 id="1-actions"><strong>1. Actions</strong></h5>
<ul>
<li>함수 이름의 동사 부분이다. 함수가 하는 일을 설명하는 가장 중요한 부분.</li>
</ul>
<p><strong>get</strong> 
데이터에 즉시 액세스 (즉, 내부 데이터의 약식 getter).</p>
<pre><code>function getFruitCount() {
  return this.fruits.length
}</code></pre><p><strong>set</strong></p>
<ul>
<li>값 A를 값 B로 사용하여 선언적 방식으로 변수를 설정한다.</li>
</ul>
<pre><code>let fruits = 0
function setFruits(nextFruits) {
  fruits = nextFruits
}
setFruits(5)
console.log(fruits) // 5</code></pre><p><strong>reset</strong></p>
<ul>
<li>변수를 초기 값 또는 상태로 다시 설정한다.</li>
</ul>
<pre><code>const initialFruits = 5
let fruits = initialFruits
setFruits(10)
console.log(fruits) // 10

function resetFruits() {
  fruits = initialFruits
}

resetFruits()
console.log(fruits) // 5</code></pre><p><strong>fetch</strong></p>
<ul>
<li>비동기 요청 즉, 불확실한 시간이 소요되는 일부 데이터 요청
function fetchPosts(postCount) {
return fetch(‘<a href="https://api.dev/posts&#39;">https://api.dev/posts&#39;</a>, {…})
}</li>
</ul>
<p><strong>remove</strong></p>
<ul>
<li>무언가를 제거
예를 들어 검색 페이지에 선택된 필터 컬렉션이 있는 경우 컬렉션에서 필터 중 하나를 제거하는 것은 deleteFilter 가 아니라 removeFilter 이다.</li>
</ul>
<pre><code>function removeFilter(filterName, filters) {
  return filters.filter((name) =&gt; name !== filterName)
}
const selectedFilters = [&#39;price&#39;, &#39;availability&#39;, &#39;size&#39;]
removeFilter(&#39;price&#39;, selectedFilters)</code></pre><p><strong>delete</strong></p>
<ul>
<li>무언가를 완전히 삭제.
없애고 싶은 게시물이 있을 때  “게시물 삭제” 버튼을 클릭시 메서드 네이밍 및 기능은 removePost 가 아닌 deletePost 작업을 수행해야 한다.</li>
</ul>
<pre><code>function deletePost(id) {
  return database.find({ id }).delete()
}</code></pre><p><strong>compose</strong></p>
<ul>
<li>기존 데이터에서 새 데이터를 생성한다. 주로 문자열, 개체 또는 함수에 적용할 수 있다.</li>
</ul>
<pre><code>function composePageUrl(pageName, pageId) {
  return `${pageName.toLowerCase()}-${pageId}`
}</code></pre><p><strong>handle</strong>
이벤트 handle 을 처리한다.  콜백 메서드의 이름을 지정할 때 자주 사용됩니다.</p>
<pre><code>function handleLinkClick() {
  console.log(&#39;Clicked a link!&#39;)
}
link.addEventListener(&#39;click&#39;, handleLinkClick)</code></pre><hr>
<h5 id="2-context"><strong>2. Context</strong></h5>
<p>함수가 작동하는 도메인( 범위 ).
함수는 종종 무언가에 대한 작업이기에 작동 가능한 도메인이 무엇인지 또는 최소한 예상되는 데이터 유형을 명시하는 것이 중요.</p>
<pre><code>/* 프리미티브로써 작동하는 순수 함수 */
function filter(predicate, list) {
  return list.filter(predicate)
}

/* 게시물에서만 정확히 작동하는 기능 */
function getRecentPosts(posts) {
  return filter(posts, (post) =&gt; post.date === Date.now())
}</code></pre><p>일부 언어 특유적으로 컨텍스트를 생략할 수 있다. 예를 들어, JavaScript 에서는 필터가 Array 에서 작동하는 것이 일반적.
명시적 filterArray 와 같이 Array 를 추가할 필요가 없다.</p>
<hr>
<h5 id="3-prefixes"><strong>3. Prefixes</strong></h5>
<ul>
<li>접두사는 변수의 의미를 향상시킨다. 함수 이름에는 거의 사용되지 않는다.</li>
</ul>
<p><strong>is</strong></p>
<ul>
<li>현재 컨텍스트(일반적으로 boolean)의 특성 또는 상태를 설명.</li>
</ul>
<pre><code>const color = &#39;blue&#39;
const isBlue = color === &#39;blue&#39; // characteristic
const isPresent = true // state

if (isBlue &amp;&amp; isPresent) {
  console.log(&#39;Blue is present!&#39;)
}</code></pre><p><strong>has</strong></p>
<ul>
<li>현재 컨텍스트가 특정 값 또는 상태(보통 부울)를 소유하는지 여부를 설명.</li>
</ul>
<pre><code>/* Bad */
const isProductsExist = productsCount &gt; 0
const areProductsPresent = productsCount &gt; 0

/* Good */
const hasProducts = productsCount &gt; 0</code></pre><p><strong>should</strong></p>
<ul>
<li>특정 작업과 결합된 긍정적인 조건문(보통 부울)을 반영.</li>
</ul>
<pre><code>function shouldUpdateUrl(url, expectedUrl) {
  return url !== expectedUrl
}</code></pre><p><strong>min/max</strong></p>
<ul>
<li>최소값 또는 최대값을 나타낸다. 경계 또는 한계를 설명할 때 사용.</li>
</ul>
<pre><code>/**
 * Renders a random amount of posts within
 * the given min/max boundaries.
 */
function renderPosts(posts, minPosts, maxPosts) {
  return posts.slice(0, randomBetween(minPosts, maxPosts))
}</code></pre><p><strong>prev/next</strong></p>
<ul>
<li>현재 컨텍스트에서 변수의 이전/다음 상태 전환을 설명할 때 사용.</li>
</ul>
<pre><code>function fetchPosts() {
  const prevPosts = this.state.posts

  const fetchedPosts = fetch(&#39;...&#39;)
  const nextPosts = concat(prevPosts, fetchedPosts)

  this.setState({ posts: nextPosts })
}</code></pre><h4 id="단수--복수--singular-and-plurals-"><strong>단수 / 복수 ( Singular and Plurals )</strong></h4>
<ul>
<li>접두사와 마찬가지로 변수 이름은 단일 값 또는 여러 값을 보유하는지 여부에 따라 단수 또는 복수로 만들 수 있다.</li>
</ul>
<pre><code>/* Bad */
const friends = &#39;Bob&#39;
const friend = [&#39;Bob&#39;, &#39;Tony&#39;, &#39;Tanya&#39;]

/* Good */
const friend = &#39;Bob&#39;
const friends = [&#39;Bob&#39;, &#39;Tony&#39;, &#39;Tanya&#39;]</code></pre><hr>
<h2 id="5-typescript">5. Typescript</h2>
<ul>
<li><p>에러 or tip</p>
</li>
<li><p>중첩된 Scope 에 기존의 변수 이름을 사용하는 것을 Shadow</p>
</li>
<li><p>api 통신하는 객체는 interface 로 구조를 잡는다.</p>
</li>
<li><p>let 과 const 중 어떤 것을 사용할지 스스로 선택. </p>
</li>
<li><p>최소 권한의 원칙(Principle of least privilege)을 적용하면 수정하려는 모든 선언은 const 를 사용한다.</p>
</li>
<li><p>조건 연산자 
<code>! -&gt; Nullable 이다.</code>
느낌표를 붙이면 null 과 undefined 를 허용한다. 즉 초기화 하지 않아도 된다.</p>
</li>
</ul>
<p><code>? -&gt; Optional 이라고 한다.</code>
말그대로 필수값이 아닌 옵셔널한 값이라는 뜻.</p>
<hr>
<h3 id="유니온union타입"><strong>유니온(Union)타입</strong></h3>
<p>유니온 타입은 하나의 프로퍼티에 다양한 변수가 올 수 있는 타입을 말한다.</p>
<p><code>let someValue: number | string</code></p>
<p>위에서 변수 someValue 는 숫자 값으로도 할당할 수 있고 문자열로도 할당할 수 있다.</p>
<p><code>let someValue: &quot;a&quot; | &quot;b&quot; | &quot;c&quot;</code></p>
<pre><code>function padLeft(value: string, padding: string | number) {
  // ...
}
let indentedString = padLeft(&quot;Hello world&quot;, true);


interface Bird {
  fly(): void;
  layEggs(): void;
}

interface Fish {
  swim(): void;
  layEggs(): void;
}

declare function getSmallPet(): Fish | Bird;

let pet = getSmallPet();
pet.layEggs();

// 두 개의 잠재적인 타입 중 하나에서만 사용할 수 있습니다.
pet.swim();
</code></pre><hr>
<h3 id="교차-타입-intersection-types"><strong>교차 타입 (Intersection Types)</strong></h3>
<p>교차 타입은 유니언 타입과 밀접한 관련이 있지만, 사용 방법은 매우 다르다. 교차 타입은 여러 타입을 하나로 결합한다. 
기존 타입을 합쳐 필요한 기능을 모두 가진 단일 타입을 얻을 수 있다. 
예를 들어, Person &amp; Serializable &amp; Loggable 은 Person 과 Serializable 그리고 Loggable 이다.
즉, 이 타입의 객체는 세 가지 타입의 모든 멤버를 갖게 됩니다.</p>
<p>예를 들어, 일관된 에러를 다루는 여러 네트워크 요청이 있다면 해당 에러 핸들링을 분리하여 하나의 응답 타입에 대응하는 결합된 자체 타입으로 만들 수 있다.</p>
<pre><code>interface ErrorHandling {
  success: boolean;
  error?: { message: string };
}

interface ArtworksData {
  artworks: { title: string }[];
}

interface ArtistsData {
  artists: { name: string }[];
}

// 이 인터페이스들은
// 하나의 에러 핸들링과 자체 데이터로 구성됩니다.

type ArtworksResponse = ArtworksData &amp; ErrorHandling;
type ArtistsResponse = ArtistsData &amp; ErrorHandling;

const handleArtistsResponse = (response: ArtistsResponse) =&gt; {
  if (response.error) {
    console.error(response.error.message);
    return;
  }

  console.log(response.artists);
};</code></pre><hr>
<h3 id="교차를-통한-믹스인-mixins-via-intersections"><strong>교차를 통한 믹스인 (Mixins via Intersections)</strong></h3>
<pre><code>class Person {
  constructor(public name: string) {}
}
interface Loggable {
  log(name: string): void;
}
class ConsoleLogger implements Loggable {
  log(name: string) {
    console.log(`Hello, I&#39;m ${name}.`);
  }
}

// 두 객체를 받아 하나로 합칩니다.
function extend&lt;First extends {}, Second extends {}&gt;(
  first: First,
  second: Second
): First &amp; Second {
  const result: Partial&lt;First &amp; Second&gt; = {};
  for (const prop in first) {
    if (first.hasOwnProperty(prop)) {
      (result as First)[prop] = first[prop];
    }
  }
  for (const prop in second) {
    if (second.hasOwnProperty(prop)) {
      (result as Second)[prop] = second[prop];
    }
  }
  return result as First &amp; Second;
}

const jim = extend(new Person(&quot;Jim&quot;), ConsoleLogger.prototype);
jim.log(jim.name);</code></pre><hr>
<h3 id="상속-inheritance"><strong>상속 (Inheritance)</strong></h3>
<pre><code>class Animal {
    name: string;
    constructor(theName: string) { this.name = theName; }
    move(distanceInMeters: number = 0) {
        console.log(`${this.name} moved ${distanceInMeters}m.`);
    }
}

class Snake extends Animal {
    constructor(name: string) { super(name); }
    move(distanceInMeters = 5) {
        console.log(&quot;Slithering...&quot;);
        super.move(distanceInMeters);
    }
}

class Horse extends Animal {
    constructor(name: string) { super(name); }
    move(distanceInMeters = 45) {
        console.log(&quot;Galloping...&quot;);
        super.move(distanceInMeters);
    }
}

let sam = new Snake(&quot;Sammy the Python&quot;);
let tom: Animal = new Horse(&quot;Tommy the Palomino&quot;);

sam.move();
tom.move(34);

//아래 코멘트는 결과 
//Slithering...
//Sammy the Python moved 5m.
//Galloping...
//Tommy the Palomino moved 34m.</code></pre><hr>
<h3 id="기본적으로-공개-public-by-default"><strong>기본적으로 공개 (Public by default)</strong></h3>
<pre><code>class Animal {
    public name: string;
    public constructor(theName: string) { this.name = theName; }
    public move(distanceInMeters: number) {
        console.log(`${this.name} moved ${distanceInMeters}m.`);
    }
}</code></pre><hr>
<h3 id="비공개-private-"><strong>비공개( private )</strong></h3>
<pre><code>class Animal {
    private name: string;
    constructor(theName: string) { this.name = theName; }
}

class Rhino extends Animal {
    constructor() { super(&quot;Rhino&quot;); }
}

class Employee {
    private name: string;
    constructor(theName: string) { this.name = theName; }
}

let animal = new Animal(&quot;Goat&quot;);
let rhino = new Rhino();
let employee = new Employee(&quot;Bob&quot;);

animal = rhino;
animal = employee; // 오류: &#39;Animal&#39;과 &#39;Employee&#39;은 호환될 수 없음.</code></pre><hr>
<h3 id="멤버-공개--protected-"><strong>멤버 공개 ( protected )</strong></h3>
<ul>
<li>아래 소스에서 Person 클래스의  name 은 사용할 수 없지만, Employee 클래스에서는 Person 에서 파생되었기 때문에 Employee 의 인스턴스 메서드 내에서는 사용 가능.</li>
</ul>
<pre><code>class Person {
    protected name: string;
    constructor(name: string) { this.name = name; }
}

class Employee extends Person {
    private department: string;

    constructor(name: string, department: string) {
        super(name);
        this.department = department;
    }

    public getElevatorPitch() {
        return `Hello, my name is ${this.name} and I work in ${this.department}.`;
    }
}

let howard = new Employee(&quot;Howard&quot;, &quot;Sales&quot;);
console.log(howard.getElevatorPitch());
console.log(howard.name); // 오류</code></pre><p>생성자 또한 protected 로 표시될 수도 있다. 이는 클래스를 포함하는 클래스 외부에서 인스턴스화 할 수 없지만 확장 할 수 있음을 의미.</p>
<pre><code>class Person {
    protected name: string;
    protected constructor(theName: string) { this.name = theName; }
}

// Employee는 Person을 확장할 수 있다.
class Employee extends Person {
    private department: string;

    constructor(name: string, department: string) {
        super(name);
        this.department = department;
    }

    public getElevatorPitch() {
        return `Hello, my name is ${this.name} and I work in ${this.department}.`;
    }
}

let howard = new Employee(&quot;Howard&quot;, &quot;Sales&quot;);
let john = new Person(&quot;John&quot;); // 오류: &#39;Person&#39;의 생성자는 protected 이다.</code></pre><hr>
<h3 id="읽기전용-readonly-modifier"><strong>읽기전용 (Readonly modifier)</strong></h3>
<p><code>readonly</code>키워드를 사용하여 프로퍼티를 읽기전용으로 만들 수 있다. 
읽기전용 프로퍼티들은 선언 또는 생성자에서 초기화해야 한다.</p>
<pre><code>class Octopus {
    readonly name: string;
    readonly numberOfLegs: number = 8;
    constructor (theName: string) {
        this.name = theName;
    }
}
let dad = new Octopus(&quot;Man with the 8 strong legs&quot;);
dad.name = &quot;Man with the 3-piece suit&quot;; // 오류! name은 읽기전용.</code></pre><hr>
<h3 id="getset-접근자-accessors"><strong>get/set 접근자 (Accessors)</strong></h3>
<p>체의 멤버에 대한 접근을 가로채는 방식으로 getters/setters를 지원한다. 이를 통해 각 객체의 멤버에 접근하는 방법을 세밀하게 제어할 수 있다.</p>
<pre><code>const fullNameMaxLength = 10;

class Employee {
    private _fullName: string;
    get fullName(): string {
        return this._fullName;
    }
    set fullName(newName: string) {
        if (newName &amp;&amp; newName.length &gt; fullNameMaxLength) {
            throw new Error(&quot;fullName has a max length of &quot; + fullNameMaxLength);
        }
        this._fullName = newName;
    }
}
let employee = new Employee();
employee.fullName = &quot;Bob Smith&quot;;
if (employee.fullName) {
    console.log(employee.fullName);
}</code></pre><hr>
<h3 id="전역-프로퍼티-static-properties"><strong>전역 프로퍼티 (Static Properties)</strong></h3>
<p>인스턴스가 아닌 클래스 자체에서 보이는 전역 멤버를 생성할 수 있다. 
아래 예제에서 모든 grid 의 일반적인 값이기 때문에 origin 에 static 을 사용한다. 
각 인스턴스는 클래스 이름을 앞에 붙여 이 값에 접근할 수 있다. 
인스턴스 접근 앞에 this.를 붙이는 것과 비슷하게 여기선 전역 접근 앞에 Grid.를 붙인다.</p>
<pre><code>class Grid {
    static origin = {x: 0, y: 0};
    calculateDistanceFromOrigin(point: {x: number; y: number;}) {
        let xDist = (point.x - Grid.origin.x);
        let yDist = (point.y - Grid.origin.y);
        return Math.sqrt(xDist * xDist + yDist * yDist) / this.scale;
    }
    constructor (public scale: number) { }
}

let grid1 = new Grid(1.0);  // 1x scale
let grid2 = new Grid(5.0);  // 5x scale

console.log(grid1.calculateDistanceFromOrigin({x: 10, y: 10}));
console.log(grid2.calculateDistanceFromOrigin({x: 10, y: 10}));</code></pre><hr>
<h3 id="추상-클래스-abstract-classes"><strong>추상 클래스 (Abstract Classes)</strong></h3>
<p>추상 클래스는 다른 클래스들이 파생될 수 있는 기초 클래스이다. 
추상 클래스는 직접 인스턴스화할 수 없다. <strong>추상 클래스는 인터페이스와 달리 멤버에 대한 구현 세부 정보를 포함할 수 있다</strong>. 
abstract 키워드는 추상 클래스뿐만 아니라 추상 클래스 내에서 추상 메서드를 정의하는데 사용된다.</p>
<pre><code>abstract class Animal {
    abstract makeSound(): void;
    move(): void {
        console.log(&quot;roaming the earth...&quot;);
    }
}</code></pre><p>추상 클래스 내에서 추상으로 표시된 메서드는 구현을 포함하지 않으며 반드시 파생된 클래스에서 구현되어야 한다. 
추상 메서드는 인터페이스 메서드와 비슷한 문법을 공유한다. 둘 다 메서드 본문을 포함하지 않고 메서드를 정의한다. 
그러나 <strong>추상 메서드는 반드시 abstract 키워드를 포함해야 하며, 선택적으로 접근 지정자를 포함할 수 있다</strong>.</p>
<pre><code>abstract class Department {
    constructor(public name: string) {
    }
    printName(): void {
        console.log(&quot;Department name: &quot; + this.name);
    }
    abstract printMeeting(): void; // 반드시 파생된 클래스에서 구현되어야 합니다.
}
class AccountingDepartment extends Department {
    constructor() {
        super(&quot;Accounting and Auditing&quot;); // 파생된 클래스의 생성자는 반드시 super()를 호출해야 합니다.
    }
    printMeeting(): void {
        console.log(&quot;The Accounting Department meets each Monday at 10am.&quot;);
    }
    generateReports(): void {
        console.log(&quot;Generating accounting reports...&quot;);
    }
}

let department: Department; // 추상 타입의 레퍼런스를 생성합니다
department = new Department(); // 오류: 추상 클래스는 인스턴스화 할 수 없습니다
department = new AccountingDepartment(); // 추상이 아닌 하위 클래스를 생성하고 할당합니다
department.printName();
department.printMeeting();
department.generateReports(); // 오류: 선언된 추상 타입에 메서드가 존재하지 않습니다</code></pre><hr>
<h3 id="열거형-enums"><strong>열거형 (Enums)</strong></h3>
<p>열거형으로 이름이 있는 상수들의 집합을 정의할 수 있다. 
열거형을 사용하면 의도를 문서화 하거나 구분되는 사례 집합을 더 쉽게 만들수 있다. 
TypeScript 는 숫자와 문자열-기반 열거형을 제공한다.</p>
<ul>
<li><strong>숫자 열거형 (Numeric enums)</strong></li>
</ul>
<pre><code>//원한다면, 전부 초기화 하지 않을 수도 있다:
enum Direction {
    Up = 1,
    Down,
    Left,
    Right,
}
//위 코드에서 Up이 1 로 초기화된 숫자 열거형을 선언. 
//그 지점부터 뒤따르는 멤버들은 자동으로-증가된 값을 갖는다. 
//즉 Direction.Up 은 1, Down 은 2, Left 는 3, Right 은 4 을 값으로 가진다.</code></pre><ul>
<li><strong>문자열 열거형 (String enums)</strong>
문자열 열거형은 유사한 개념이지만 아래 설명된 것과 같이 런타임에서 열거형의 동작이 약간 다르다.
문자열 열거형에서 각 멤버들은 문자열 리터럴 또는 다른 문자열 열거형의 멤버로 상수 초기화 해야 한다.</li>
</ul>
<p>문자열 열거형은 숫자 열거형처럼 자동-증가하는 기능은 없지만, “직렬화”를 잘한다는 이점이 있다. 
다시 말해서 숫자 열거형을 이용해서 디버깅하고 있고 그 값을 읽어야 한다면, 종종 그 값이 불확실한 경우가 있다 - 숫자만으로는 이것이 어떤 의미인지 유의미한 정보를 제공해주지 않기 때문이다.
반면 문자열 열거형을 이용하면 코드를 실행할 때, 열거형 멤버에 지정된 이름과는 무관하게 유의미하고 읽기 좋은 값을 이용하여 실행할 수 있다.</p>
<pre><code>enum Direction {
    Up = &quot;UP&quot;,
    Down = &quot;DOWN&quot;,
    Left = &quot;LEFT&quot;,
    Right = &quot;RIGHT&quot;,
}</code></pre><blockquote>
<p>note: 기술적으로 열거형은 숫자와 문자를 섞어서 사용할 수 있지만 굳이 그렇게 할 이유는 없다.</p>
</blockquote>
<hr>
<h3 id="다형성-this-타입-polymorphic-this-types"><strong>다형성 this 타입 (Polymorphic this types)</strong></h3>
<pre><code>class BasicCalculator {
    public constructor(protected value: number = 0) { }
    public currentValue(): number {
        return this.value;
    }
    public add(operand: number): this {
        this.value += operand;
        return this;
    }
    public multiply(operand: number): this {
        this.value *= operand;
        return this;
    }
    // ... 다른 연산들은 여기에 작성 ...
}

let v = new BasicCalculator(2)
            .multiply(5)
            .add(1)
            .currentValue();

//클래스가 this 타입을 사용하기 때문에, 이를 extend 할 수 있고 새로운 클래스가 아무 변경 없이 이전 메서드를 사용할 수 있다.
class ScientificCalculator extends BasicCalculator {
    public constructor(value = 0) {
        super(value);
    }
    public sin() {
        this.value = Math.sin(this.value);
        return this;
    }
    // ... 다른 연산들은 여기에 작성 ...
}

let v = new ScientificCalculator(2)
        .multiply(5)
        .sin()
        .add(1)
        .currentValue();
// this 타입 없이, ScientificCalculator는 BasicCalculator를 extend 할 수 없을 것이고 유연한 인터페이스를 유지하지 못한다. 
// multiply는 sin 메서드를 가지지 않는 BasicCalculator를 반환한다. 하지만, this 타입으로, multiply는 this를 반환하고, 여기서는 ScientificCalculator 을 가르킨다.</code></pre><hr>
<h3 id="인덱스-타입-index-types"><strong>인덱스 타입 (Index types)</strong></h3>
<p>일반적인 js 패턴 </p>
<pre><code>function pluck(o, propertyNames) {
    return propertyNames.map(n =&gt; o[n]);
}</code></pre><p>TypeScript 에서 인덱스 타입 패턴</p>
<ul>
<li><p>인덱스 타입을 사용하면, 동적인 프로퍼티 이름을 사용하는 코드를 컴파일러가 검사할 수 있다.</p>
</li>
<li><p>인덱스 타입 쿼리와 인덱스 접근 연산자를 사용해서 TypeScript 에서 이 함수를 어떻게 작성하고 사용하는지 보여준다:</p>
<pre><code>function pluck&lt;T, K extends keyof T&gt;(o: T, propertyNames: K[]): T[K][] {
 return propertyNames.map(n =&gt; o[n]);
}

interface Car {
   manufacturer: string;
   model: string;
   year: number;
}
let taxi: Car = {
   manufacturer: &#39;Toyota&#39;,
   model: &#39;Camry&#39;,
   year: 2014
};

// Manufacturer과 model은 둘 다 문자열 타입.
// 그래서 둘 다 타이핑된 문자열 배열로 끌어낼 수 있다.
let makeAndModel: string[] = pluck(taxi, [&#39;manufacturer&#39;, &#39;model&#39;]);

// 만약 model과 year를 끌어내려고 하면,
// 유니언 타입의 배열: (string | number)[] 을 얻게 된다.
let modelYear = pluck(taxi, [&#39;model&#39;, &#39;year&#39;])</code></pre></li>
</ul>
<hr>
<h3 id="인덱스-타입과-인덱스-시그니처-index-types-and-index-signatures"><strong>인덱스 타입과 인덱스 시그니처 (Index types and index signatures)</strong></h3>
<p>keyof 와 T[K] 가 인덱스 시그니처와 상호 작용한다. 인덱스 시그니처 매개변수 타입은 ‘string’ 혹은 ‘number’ 이어야 한다. 
만약 문자열 인덱스 시그니처인 타입이 있으면, keyof T는 string | number 가 될 것이다 (그냥 string 이 아니고, JavaScript 에선 문자열 (object[‘42’])나 숫자 (object[42])를 사용해서 객체 프로퍼티에 접근할 수 있다). 
그리고 T[string]은 인덱스 시그니처의 타입이다.</p>
<pre><code>interface Dictionary&lt;T&gt; {
    [key: string]: T;
}
let keys: keyof Dictionary&lt;number&gt;; // string | number
let value: Dictionary&lt;number&gt;[&#39;foo&#39;]; // number

-------------------------------

//숫자 인덱스 시그니처인 타입이 있으면, keyof T는 number일 것이다.
interface Dictionary&lt;T&gt; {
    [key: number]: T;
}
let keys: keyof Dictionary&lt;number&gt;; // 숫자
let value: Dictionary&lt;number&gt;[&#39;foo&#39;]; // 오류, 프로퍼티 &#39;foo&#39;는 타입 &#39;Dictionary&lt;number&gt;&#39;에 존재하지 않습니다.
let value: Dictionary&lt;number&gt;[42]; // 숫자</code></pre><hr>
<h3 id="매핑-타입-mapped-types"><strong>매핑 타입 (Mapped types)</strong></h3>
<ul>
<li>기존 타입을 가져와 선택적 프로퍼티로 만드는 것은 일반적인 작업.</li>
</ul>
<pre><code>type Readonly&lt;T&gt; = {
    readonly [P in keyof T]: T[P];
}
type Partial&lt;T&gt; = {
    [P in keyof T]?: T[P];
}


//사용하기 위해선 아래와 같이
type PersonPartial = Partial&lt;Person&gt;;
type ReadonlyPerson = Readonly&lt;Person&gt;;</code></pre><hr>
<h3 id="객체-순회-노하우">객체 순회 노하우</h3>
<pre><code>
const obj={
  one: &#39;uno&#39;,
  two: &#39;dos&#39;,
  three: &#39;tres&#39;
}
let k: keyof typeof obj;
for(k in obj){
  const v=obj[k];
  // ~~~~~~~~~~~에러 :  obj 에 인덱스 시그니처가 없기 때문에 엘리먼트는 암시적으로 &#39;any&#39; 타입입니다.
}

// k 타입을 구체적으로 명시하면 된다.
let k: keyof typeof obj;
for(k in obj){
  const v=obj[k];
}</code></pre><pre><code>interface ABC{
  a: string;
  b: string;
  c: string;
}

function foo(abc: ABC){
   for(const k in abc){
      const v=abc[k];
      // ~~~~~~~~~~~~~~ &#39;ABC&#39; 타입에 인덱스 시그니처가 없기 때문에 엘리먼트는 암시적으로 &#39;any&#39;가 됩니다.
   }
}
// const x={ a:&#39;a&#39;, b: &#39;b&#39;, c:2, d: new Date()} 
// foo(x); // 정상 처리 됨.
// foo 함수는 a,b,c 속성 외에 d 를 가지는 x 객체로 호출이 가능하다. 즉 foo 함수는 ABC 타입에 할당 가능한 어떠한 값이든 매개변수로 허용하기 때문

-&gt; 다음과 같이 수정
function foo(abc: ABC){
   for(const [k, v] in Object.entries(abc)){
      // k =&gt; string 타입 
      // v =&gt; any 타입 
      const v=abc[k];
   }
}</code></pre><hr>
<h3 id="type-별칭-및-interface-사용-구분"><strong>type 별칭 및 interface 사용 구분</strong></h3>
<p>-Use an interface instead of a type literal.
타입은 리터럴 타입에서만 사용하고 Object 형태의 타입은 인터페이스를 쓰라는 소리다.
type 별칭은 리터럴 타입의 값에만 사용하고, Object 형태의 타입을 잡아줄 때는 Interface 를 사용하면 고민없이 행복해진다.</p>
<pre><code>export type TSomeMemberTier = &quot;Basic&quot; | &quot;Premium&quot; | &quot;Admin&quot;;

export interface ISomeMember {
  name: string;
  age: number;
  address: string;
  tier: TSomeMemberTier;
}</code></pre><ul>
<li><p>Destructuring</p>
</li>
<li><p>함수</p>
<pre><code>function f([first, second]: [number, number]) {
  console.log(first);
  console.log(second);
}
f([1, 2]);</code></pre></li>
<li><p>객체</p>
<pre><code>({ a, b } = { a: &quot;baz&quot;, b: 101 });
//
let { a, b }: { a: string, b: number } = o;</code></pre></li>
</ul>
<hr>
<h3 id="타입스크립트에서-유용한-유틸"><strong>타입스크립트에서 유용한 유틸</strong></h3>
<h4 id="omittk"><strong>Omit&lt;T,K&gt;</strong></h4>
<ul>
<li>T에서 모든 프로퍼티를 선택한 다음 K를 제거한 타입을 구성.</li>
</ul>
<pre><code>// Example
interface Todo {
    title: string;
    description: string;
    completed: boolean;
}
type TodoPreview = Omit&lt;Todo, &#39;description&#39;&gt;;
const todo: TodoPreview = {
    title: &#39;Clean room&#39;,
    completed: false,
};</code></pre><hr>
<h4 id="picktk"><strong>Pick&lt;T,K&gt;</strong></h4>
<p>T에서 프로퍼티 K의 집합을 선택해 타입을 구성.</p>
<pre><code>// 예제 (Example)
interface Todo {
    title: string;
    description: string;
    completed: boolean;
}
type TodoPreview = Pick&lt;Todo, &#39;title&#39; | &#39;completed&#39;&gt;;
const todo: TodoPreview = {
    title: &#39;Clean room&#39;,
    completed: false,
};</code></pre><hr>
<h4 id="keyof"><strong>keyof</strong></h4>
<p>keyof 키워드는 타입 값에 존재하는 모든 프로퍼티의 키값을 union 형태로 리턴 받다.</p>
<pre><code>interface Todo {
    id: number;
    text: string;
    due: Date;
}

// TodoKeys의 타입 = &quot;id&quot; | &quot;text&quot; | &quot;due&quot;
type TodoKeys = keyof Todo;</code></pre><hr>
<h4 id="recordkt"><strong>Record&lt;K,T&gt;</strong></h4>
<p>타입 T의 프로퍼티의 집합 K로 타입을 구성한다. 
이 유틸리티는 타입의 프로퍼티들을 다른 타입에 매핑시키는 데 사용될 수 있다.
Record&lt;K, V&gt;로 쓰인다. 여기서 K는 key 이고, V는 Value 다. </p>
<pre><code>//예제 (Example)

export type GlobalColors = &#39;Red&#39; | &#39;Blue&#39; | &#39;Green&#39; | &#39;Black&#39;
type ColorProperties = Record&lt;GlobalColors, string&gt;

//위 두줄 typescript는 아래와 같다
type ColorProperties = {
  red: string
  blue: string
  green: string
  black: string
}

——————

interface PageInfo {
    title: string;
}
type Page = &#39;home&#39; | &#39;about&#39; | &#39;contact&#39;;
const x: Record&lt;Page, PageInfo&gt; = {
    about: { title: &#39;about&#39; },
    contact: { title: &#39;contact&#39; },
    home: { title: &#39;home&#39; },
};
</code></pre><hr>
<h4 id="partialt"><strong>Partial&lt;T&gt;</strong></h4>
<p>Partial 은 key 를 옵셔널하게 해준다.
T의 모든 프로퍼티를 선택적으로 만드는 타입을 구성한다. 
이 유틸리티는 주어진 타입의 모든 하위 타입 집합을 나타내는 타입을 반환한다.</p>
<pre><code>예제 (Example)

export type GlobalColors = &#39;Red&#39; | &#39;Blue&#39; | &#39;Green&#39; | &#39;Black&#39;
type ColorProperties = Record&lt;GlobalColors, string&gt;

//위 두줄 typescript는 아래와 같다
type ColorProperties = {
  red: string
  blue: string
  green: string
  black: string
}

// 이거는
let PartialColorProperties = Partial&lt;ColorProperties&gt;
// 이거와 같다.
let PartialColorProperties = { red?: string, blue?: string, green?: string, black?: string }

——————

interface Todo {
    title: string;
    description: string;
}

function updateTodo(todo: Todo, fieldsToUpdate: Partial&lt;Todo&gt;) {
    return { ...todo, ...fieldsToUpdate };
}

const todo1 = {
    title: &#39;organize desk&#39;,
    description: &#39;clear clutter&#39;,
};

const todo2 = updateTodo(todo1, {
    description: &#39;throw out trash&#39;,
});</code></pre><p>정리 </p>
<pre><code>// 글로벌 색으로 4가지를 선언한다.
export type GlobalColors = &#39;Red&#39; | &#39;Blue&#39; | &#39;Green&#39; | &#39;Black&#39;

// 기본값으로 색상을 선언한다.
const enum ConstGlobalColorSet {
  Red = &#39;11, 11, 11&#39;,
  Blue = &#39;22, 22, 22&#39;,
  Green = &#39;33, 33, 33&#39;,
  Black = &#39;44, 44, 44&#39;,
}

// 기본 색상값외에 다른 색상을 사용하고 싶다면
const CUSTOM_COLORS: Partial&lt;Record&lt;GlobalColors, string&gt;&gt; = {
  gray: &#39;55, 55, 55&#39;,
}</code></pre><hr>
<h4 id="parameterst"><strong>Parameters&lt;T&gt;</strong></h4>
<p>함수 타입 T의 매개변수 타입들의 튜플 타입을 구성.</p>
<pre><code>예제 (Example)
declare function f1(arg: { a: number, b: string }): void
type T0 = Parameters&lt;() =&gt; string&gt;;  // []
type T1 = Parameters&lt;(s: string) =&gt; void&gt;;  // [string]
type T2 = Parameters&lt;(&lt;T&gt;(arg: T) =&gt; T)&gt;;  // [unknown]
type T4 = Parameters&lt;typeof f1&gt;;  // [{ a: number, b: string }]
type T5 = Parameters&lt;any&gt;;  // unknown[]
type T6 = Parameters&lt;never&gt;;  // never
type T7 = Parameters&lt;string&gt;;  // 오류
type T8 = Parameters&lt;Function&gt;;  // 오류</code></pre><hr>
<h4 id="returntypet"><strong>ReturnType&lt;T&gt;</strong></h4>
<p>함수 T의 반환 타입으로 구성된 타입을 만듭니다.</p>
<pre><code>예제 (Example)
declare function f1(): { a: number, b: string }
type T0 = ReturnType&lt;() =&gt; string&gt;;  // string
type T1 = ReturnType&lt;(s: string) =&gt; void&gt;;  // void
type T2 = ReturnType&lt;(&lt;T&gt;() =&gt; T)&gt;;  // {}
type T3 = ReturnType&lt;(&lt;T extends U, U extends number[]&gt;() =&gt; T)&gt;;  // number[]
type T4 = ReturnType&lt;typeof f1&gt;;  // { a: number, b: string }
type T5 = ReturnType&lt;any&gt;;  // any
type T6 = ReturnType&lt;never&gt;;  // any
type T7 = ReturnType&lt;string&gt;;  // 오류
type T8 = ReturnType&lt;Function&gt;;  // 오류</code></pre><hr>
<h4 id="instancetypet"><strong>InstanceType&lt;T&gt;</strong></h4>
<p>클래스 생성자의 인스턴스 타입을 구한다.</p>
<pre><code>예제 (Example)
type A={new(): B}
type B={b: number}
type I= InstanceType&lt;A&gt; // {b: number}</code></pre><hr>
<h4 id="constructorparameterst"><strong>ConstructorParameters&lt;T&gt;</strong></h4>
<p><code>ConstructorParameters&lt;T&gt;</code>타입은 생성자 함수 타입의 모든 매개변수 타입을 추출할 수 있게 해준다. 
모든 매개변수 타입을 가지는 튜플 타입(T가 함수가 아닌 경우 never)을 생성.</p>
<pre><code>예제 (Example)
type T0 = ConstructorParameters&lt;ErrorConstructor&gt;;  // [(string | undefined)?]
type T1 = ConstructorParameters&lt;FunctionConstructor&gt;;  // string[]
type T2 = ConstructorParameters&lt;RegExpConstructor&gt;;  // [string, (string | undefined)?]</code></pre><hr>
<h2 id="6-image-및-font-구조">6. Image 및 Font 구조</h2>
<table>
<thead>
<tr>
<th align="left">Directory</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">dist/assets/images</td>
<td align="left">이미지 경로</td>
</tr>
<tr>
<td align="left">dist/assets/images/common</td>
<td align="left">공통요소 이미지 경로</td>
</tr>
<tr>
<td align="left">dist/assets/images/main</td>
<td align="left">메인페이지 이미지 경로</td>
</tr>
<tr>
<td align="left">dist/assets/images/pages</td>
<td align="left">서브페이지 이미지 경로</td>
</tr>
<tr>
<td align="left">dist/assets/font</td>
<td align="left">공통 폰트 경로</td>
</tr>
</tbody></table>
<hr>
<h2 id="7-javascript-및-라이브러리-구조">7. Javascript 및 라이브러리 구조</h2>
<table>
<thead>
<tr>
<th align="left">Directory</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">dist/assets/js</td>
<td align="left">javascript 경로</td>
</tr>
<tr>
<td align="left">dist/assets/js/apps.js</td>
<td align="left">gnb 활성화 변수( singleton 정의 js  )</td>
</tr>
<tr>
<td align="left">dist/assets/js/common.js</td>
<td align="left">gnb 및 공통 기능 정의 js</td>
</tr>
<tr>
<td align="left">dist/assets/js/Utils.js</td>
<td align="left">유틸 기능 정의 js</td>
</tr>
<tr>
<td align="left">dist/assets/vendors/bootstrap</td>
<td align="left">화면 레이아웃 및 요소 지원( 부트스트랩 라이브러리 )</td>
</tr>
<tr>
<td align="left">dist/assets/vendors/jquery</td>
<td align="left">화면(dom) 컨트롤 지원 ( jquery js 라이브러리 )</td>
</tr>
<tr>
<td align="left">dist/assets/vendors/greensock/TweenMax</td>
<td align="left">모션 컨트롤 지원 ( js 라이브러리 )</td>
</tr>
<tr>
<td align="left">dist/assets/vendors/swiper/swiper</td>
<td align="left">캐러셀 컨트롤 지원 ( css/js 라이브러리 )</td>
</tr>
</tbody></table>
<h2 id="8-directory">8. Directory</h2>
<h3 id="8-1-배포용-폴더-구성">8-1. 배포용 폴더 구성</h3>
<table>
<thead>
<tr>
<th align="left">Directory</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">dist/assets/images</td>
<td align="left">이미지 경로</td>
</tr>
<tr>
<td align="left">dist/assets/images/common</td>
<td align="left">이미지 경로</td>
</tr>
<tr>
<td align="left">dist/assets/images/main</td>
<td align="left">메인페이지 이미지 경로</td>
</tr>
<tr>
<td align="left">dist/assets/font</td>
<td align="left">공통 폰트 경로</td>
</tr>
<tr>
<td align="left">dist/assets/js</td>
<td align="left">javascript 경로</td>
</tr>
<tr>
<td align="left">dist/assets/vendors</td>
<td align="left">라이브러리</td>
</tr>
<tr>
<td align="left">dist/pages</td>
<td align="left">html</td>
</tr>
</tbody></table>
<hr>
<h3 id="8-2-로컬-개발용-폴더-구성">8-2. 로컬 개발용 폴더 구성</h3>
<table>
<thead>
<tr>
<th align="left">Directory</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">src/assets/images</td>
<td align="left">이미지 경로</td>
</tr>
<tr>
<td align="left">src/assets/images/common</td>
<td align="left">이미지 경로</td>
</tr>
<tr>
<td align="left">src/assets/images/main</td>
<td align="left">메인페이지 이미지 경로</td>
</tr>
<tr>
<td align="left">src/assets/font</td>
<td align="left">공통 폰트 경로</td>
</tr>
<tr>
<td align="left">src/assets/js</td>
<td align="left">javascript 경로</td>
</tr>
<tr>
<td align="left">src/assets/scss</td>
<td align="left">scss 경로</td>
</tr>
<tr>
<td align="left">src/assets/scss/default</td>
<td align="left">공통 scss 경로</td>
</tr>
<tr>
<td align="left">src/assets/scss/pages</td>
<td align="left">1depth 카테고리별 scss 경로</td>
</tr>
<tr>
<td align="left">src/assets/vendors</td>
<td align="left">라이브러리</td>
</tr>
<tr>
<td align="left">src/pages</td>
<td align="left">html</td>
</tr>
</tbody></table>
<hr>
<h2 id="9-문서-구조">9. 문서 구조</h2>
<h4 id="head-부분">head 부분</h4>
<pre><code>&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta content=&quot;IE=edge&quot; http-equiv=&quot;X-UA-Compatible&quot;&gt;
    &lt;meta content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no&quot; name=&quot;viewport&quot;&gt;
    &lt;meta content=&quot;&quot; name=&quot;keywords&quot;&gt;
    &lt;meta content=&quot;&quot; name=&quot;description&quot;&gt;
    &lt;meta content=&quot;&quot; property=&quot;og:title&quot;&gt;
    &lt;meta content=&quot;&quot; property=&quot;og:url&quot;&gt;
    &lt;meta content=&quot;&quot; property=&quot;og:description&quot;&gt;
    &lt;meta content=&quot;&quot; property=&quot;og:image&quot;&gt;
    &lt;meta content=&quot;website&quot; property=&quot;og:type&quot;&gt;
    &lt;meta content=&quot;&quot; property=&quot;og:site_name&quot;&gt;
    &lt;meta content=&quot;&quot; name=&quot;title&quot;&gt;

    &lt;!-- inject:css --&gt;
    &lt;link href=&quot;../assets/vendors/bootstrap/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;
    &lt;link href=&quot;../assets/vendors/swiper/css/swiper.min.css&quot; rel=&quot;stylesheet&quot;&gt;
    &lt;link href=&quot;../assets/css/common.css&quot; rel=&quot;stylesheet&quot;&gt;
    &lt;link href=&quot;../assets/css/sub.css&quot; rel=&quot;stylesheet&quot;&gt;
    &lt;!-- endinject --&gt;


    &lt;!-- inject:dependency:js --&gt;
    &lt;script src=&quot;../assets/vendors/jquery/jquery-1.10.2.min.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;../assets/vendors/bootstrap/js/bootstrap.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;../assets/vendors/greensock/TweenMax.min.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;../assets/vendors/swiper/js/swiper.min.js&quot;&gt;&lt;/script&gt;
    &lt;!-- endinject --&gt;

    &lt;!-- inject:head:js --&gt;
    &lt;script src=&quot;../assets/js/apps.js&quot;&gt;&lt;/script&gt;
    &lt;!-- endinject --&gt;
&lt;/head&gt;</code></pre><h3 id="body-부분">body 부분</h3>
<blockquote>
<p>note :</p>
<ul>
<li>메인페이지일 경우 wrapper 부분은 div class=”wrapper main” 라고 지정.</li>
<li>서브페이지일 경우 wrapper 부분은 div class=”wrapper sub” 라고 지정.</li>
<li>서브페이지에서 추가 구분은 추가명칭 flag 가 붙는다. 회원가입 페이지 경우 div class=”wrapper sub sign-up” 처럼 구분 된다.</li>
</ul>
</blockquote>
<pre><code>&lt;div class=&quot;wrapper sub sign-up&quot;&gt;

    &lt;!--start:skip --&gt;
    &lt;div id=&quot;skip&quot;&gt;
        &lt;a href=&quot;#gnb&quot;&gt;주메뉴 바로가기&lt;/a&gt;
        &lt;a href=&quot;#contents&quot;&gt;본문 바로가기&lt;/a&gt;
        &lt;a href=&quot;#footer&quot;&gt;하단 바로가기&lt;/a&gt;
    &lt;/div&gt;
    &lt;!--//end:skip --&gt;

    &lt;!-- start: header / gnb --&gt;
    &lt;header&gt;
        &lt;div class=&quot;header-container clearfix&quot;&gt;

            &lt;!--start: gnb full type --&gt;
            &lt;nav id=&quot;gnb&quot;&gt;
                &lt;div class=&quot;menu-container&quot;&gt;
                    &lt;h1&gt;&lt;a class=&quot;top-logo&quot; href=&quot;#&quot; title=&quot;로고&quot;&gt;..............&lt;/a&gt;&lt;/h1&gt;
                    &lt;p class=&quot;blind&quot;&gt;주 메뉴시작&lt;/p&gt;
                    &lt;ul class=&quot;dep1-group local clearfix&quot;&gt;
                        &lt;li class=&quot;nv-item&quot;&gt;

                        .............................중략.............................

    &lt;/header&gt;
    &lt;!-- end: header / gnb --&gt;

    &lt;section class=&quot;container-fluid&quot;&gt;
        &lt;div id=&quot;contents&quot;&gt;
             &lt;!-- start: 컨텐츠 상단( 주로 타이틀/ stepper 요소등  ) --&gt;
            &lt;div class=&quot;sub-top&quot;&gt;
                &lt;h2 class=&quot;sub-tit&quot;&gt;타이틀&lt;/h2&gt;

            &lt;/div&gt;
            &lt;!-- start: 컨텐츠 상단( 주로 타이틀/ stepper 요소등  ) --&gt;

            &lt;!-- start: 컨텐츠 내용 --&gt;
            &lt;div class=&quot;sub-contents&quot;&gt; &lt;/div&gt;
            &lt;!-- end: 컨텐츠 내용 --&gt;

            &lt;!-- start: 컨텐츠 하단 내용 --&gt;
            &lt;div class=&quot;sub-btm&quot;&gt; &lt;/div&gt;
             &lt;!-- end: 컨텐츠 하단 내용 --&gt;
        &lt;/div&gt;

    &lt;/section&gt;

    &lt;footer id=&quot;footer&quot;&gt;&lt;/footer&gt;
</code></pre><hr>
<h2 id="11-node-버전-관리">11. node 버전 관리</h2>
<ul>
<li>노드 기반 즉 의존성이 포함된 라이브러리를 많이 쓰는 경우에 협업자들끼리 node 버전을 맞추지 않으면 매번 의존성 라이브러리들을 설치하거나
깃에서 충돌이 날 것이다. 이럴때 간편하게 node 를 설치하고 버전관리를 해주는 것이 nvm 이라는 것이 있다.</li>
</ul>
<blockquote>
<p>note: curl 로 설치 </p>
<ul>
<li><code>sudo curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.1/install.sh | bash</code></li>
<li>sudo 명령어를 썼기에 사용자 비번 넣으라고 나올 것이다. 가볍게 비번을 넣어주면 설치 뙁 ~!!!!</li>
<li>설치 후 잘 설치 되었는지 터미널에서 확인 <code>nvm ls-remote</code></li>
</ul>
</blockquote>
<p>command not found 라는 문구가 뜨면서 안되는 경우가 있다.<br>다음과 같이 해보자..</p>
<p><strong>1. 터미널에 .bash_profile 있는지 확인</strong>( 참고로 필자는 최상위 루트에서 터미널 명령어를 실행했다. )
-&gt; 명령어 find ./.bash_profile</p>
<p>아래와 같이 파일이 존재할 경우 아래 처럼 해당 파일이 있다고 알려줄 것이다.
./.bash_profile</p>
<p>없다면 find: ./.bash_profile:No such file or directory 라는 문구가 뜰 것이다.</p>
<p><strong>2.bash_profile 에 내용 추가</strong> 
위 내용에서 .bash_profile 이 없는 경우엔 만들어 준다.
터미널에 다음과 같이 .bash_profile을 만든다. –&gt; <code>touch .bash_profile</code></p>
<p>.bash_profile 이 있는 경우엔 터미널에 다음 명령어를 치고 내용확인 -&gt; <code>open .bash_profile</code></p>
<p>.bash_profile 안에 코드는 아래와 같다.
<code>export NVM_DIR=&quot;$HOME/.nvm&quot; [ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; . &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm</code></p>
<p>그리고 다시 설치~ </p>
<h3 id="10-1-nvm-에서-자주-사용할-명령어">10-1. nvm 에서 자주 사용할 명령어</h3>
<p><code>nvm --version</code>   ( 설치된 nvm 버전 )</p>
<p><code>node --version</code>  ( 설치된 node 버전 )</p>
<p><code>nvm ls</code> ( 현재 설치된 버전을 보여준다. )</p>
<p><code>nvm ls-remote</code>( 설치 가능한  node 버전을 알려준다. )</p>
<p><code>nvm install v5</code>  ( node 5버전대에 latest 버전을 설치한다. )</p>
<p><code>nvm use v5</code>  ( node 설치된 v5버전으로 사용한다. )</p>
<hr>
<h3 id="10-2-mac-m2-환경에서-nvm-설치">10-2. mac m2 환경에서 nvm 설치</h3>
<ol>
<li>brew 로 nvm 설치</li>
</ol>
<ul>
<li><code>brew install nvm</code></li>
</ul>
<ol start="2">
<li>설치 되었는지 버전 확인</li>
</ol>
<ul>
<li><code>nvm --version</code></li>
</ul>
<p>설치가 안되고 nvm not found라는 에러 나오면 환경설정 수정해야 한다.</p>
<ol>
<li>z shell 을 연다.
( 기본 쉘 (Shell) 이 bash 에서 zsh (Z shell)로 변경 )</li>
</ol>
<ul>
<li><code>vi ~/.zshrc</code></li>
</ul>
<ol start="2">
<li>쉘스크립트가 열리면 아래 코드를 입력한다 ( vi 로 열었을때 i 를 누르면 insert 즉 입력가능해진다 )<pre><code>export NVM_DIR=&quot;$HOME/.nvm&quot;
[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \. &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm</code></pre><pre><code>export NVM_DIR=~/.nvm
export PATH=/opt/homebrew/bin:$PATH
source $(brew --prefix nvm)/nvm.sh</code></pre></li>
</ol>
<p>export PATH=/opt/homebrew/bin:$PATH 라는 내용은 command not found : brew 라는 에러 발생해서 추가해 주었던 부분이다.
참고로 해당 에러 발생은 ‘Homebrew가 /usr/local/… 가 아닌  /opt/homebrew/ 에 설정되어 있어서 그렇다’ 라고 해서 해당 부분은 경로를 추가해 해결하였다. 아래는 쉘스크립트에서 기존의 $PATH 값에 새로운 경로추가시 경로 추가하는 법이다.
( 추가되는 디렉렉터리는 :(쌍점, 콜론)으로 구분 )
PATH=/추가경로1:/추가경로2:$PATH</p>
<ol start="3">
<li><p>입력이 끝나면 esc키 누른다. 그리고 :wq ( 저장후 종료 ) 타이핑을 치고 엔터 누르면 편집에서 빠져나오게 된다.</p>
</li>
<li><p>source 명령어로 아까 입력한 부분을 실행시킨다.
( 참고로 source 명령어는 command를 읽고 실행하는 bash 내장 명령어 )</p>
</li>
</ol>
<ul>
<li><code>source ~/.zshrc</code></li>
</ul>
<h3 id="10-3-window-에서-nvm-설치">10-3. window 에서 nvm 설치</h3>
<ol>
<li>NVM 설치 파일 다운로드</li>
</ol>
<ul>
<li><a href="https://github.com/coreybutler/nvm-windows/releases">https://github.com/coreybutler/nvm-windows/releases</a></li>
<li>위 주소에 접속하여 nvm-setup.zip 파일을 다운 받는다.</li>
</ul>
<ol start="2">
<li><p>NVM 설치 방법</p>
<ul>
<li>받은 압축 파일을 풀고 nvm을 install 한다.</li>
<li>windows 명령 프롬프트 cmd를 실행한다.</li>
<li>nvm version을 입력하여 설치된 것을 확인한다.</li>
</ul>
</li>
<li><p>nodejs &amp; npm 설치 방법</p>
<ul>
<li>nvm install v10.16.3 입력 설치</li>
<li>nvm ls 를 입력 &gt; 버전을 확인.</li>
<li>nvm use 10.15.2 를 입력 &gt; 해당 버전의 nodejs 활성</li>
</ul>
</li>
</ol>
<hr>
<h2 id="11-개발-환경-설정">11. 개발 환경 설정.</h2>
<ul>
<li>es6 / scss / readme.md  / 파일등을 컴파일 해서 최종 산출물을 전달한다.</li>
<li>그렇게 하려면 별도의 컴파일 task runner( gulp 로 설정 ) 가 필요하다.
( 현재는 모듈화 작업 즉 angular/vue/react 등의 spa 로  entry point 인 하나의 파일로 진입하는 모듈 작업은 거의 없기에 
webpack 과 같은 모듈러는 사실상 필요가 없다. )</li>
</ul>
<ol>
<li>초기 설정. (해당 프로젝트 폴더로 터미널경로를 이동되어 있어야 한다)
매 프로젝트마다 저 선언은 해주어야 package.json 이 생성된다. ( npm에 의한 프로젝트 의존성 모듈 설정 파일 )</li>
</ol>
<pre><code>npm init</code></pre><ol start="2">
<li>gulp 전역(global)설치</li>
</ol>
<pre><code>npm install -g gulp</code></pre><ol start="3">
<li>프로젝트내 local gulp devDependency 설치</li>
</ol>
<pre><code>npm install --save-dev gulp</code></pre><ol start="4">
<li>gulpfile.babel.js 생성</li>
</ol>
<pre><code>touch gulpfile.babel.js</code></pre><ol start="5">
<li>Babel  설치( ES2015 + 기능 및 호환성 문제를 피하기 위해) </li>
</ol>
<pre><code>npm install --save-dev @babel/register @babel/core @babel/preset-env</code></pre><ol start="6">
<li>babel 설정파일 .babelrc 을 생성</li>
</ol>
<p><code>touch .babelrc</code></p>
<ol start="7">
<li>.babelrc 파일을 열고 아래 내용을 입력.</li>
</ol>
<pre><code>{
    &quot;presets&quot;: [ &quot;@babel/preset-env&quot; ]
}</code></pre><p>마지막으로 의존성 파일들 설치 ( package.json 에 명시된 라이브러리들 )</p>
<pre><code>&quot;del&quot;: &quot;^5.1.0&quot;,
&quot;fibers&quot;: &quot;^4.0.1&quot;,
&quot;gulp-autoprefixer&quot;: &quot;^7.0.1&quot;,
&quot;gulp-babel&quot;: &quot;^8.0.0&quot;,
&quot;gulp-cheerio&quot;: &quot;^0.6.3&quot;,
&quot;gulp-clean-css&quot;: &quot;^4.2.0&quot;,
&quot;gulp-concat&quot;: &quot;^2.6.1&quot;,
&quot;gulp-imagemin&quot;: &quot;^6.1.1&quot;,
&quot;gulp-inject&quot;: &quot;^5.0.4&quot;,
&quot;gulp-markdown&quot;: &quot;^5.0.0&quot;,
&quot;gulp-rename&quot;: &quot;^1.4.0&quot;,
&quot;gulp-sass&quot;: &quot;^4.0.2&quot;,
&quot;gulp-sort&quot;: &quot;^2.0.0&quot;,
&quot;gulp-sourcemaps&quot;: &quot;^2.6.5&quot;,
&quot;gulp-uglify&quot;: &quot;^3.0.2&quot;,
&quot;gulp-watch&quot;: &quot;^5.0.1&quot;,
&quot;lodash&quot;: &quot;^4.17.15&quot;,
&quot;pygmentize-bundled&quot;: &quot;^2.3.0&quot;,
&quot;stream-series&quot;: &quot;^0.1.1&quot;</code></pre><p>위의 내용들을 개별로 설치하기 부담스럽다면  다운로드 링크 : <a href="./package.json">package.json</a> 을 다운받아서
프로젝트 폴더내에 root경로에 놓고 터미널에<code>npm install</code> 하면 관련 의존성 파일들을 알아서 설치해 줄 것이다.</p>
<hr>
<h2 id="12-형상관리--git-">12. 형상관리 ( git )</h2>
<blockquote>
<p>note : git 기반 - 현재 <a href="https://bitbucket.org/">비트버킷 https://bitbucket.org/</a>으로 공유 중 </p>
</blockquote>
<h4 id="12-1-원격-저장소-연결">12-1. 원격 저장소 연결</h4>
<p><code>git remote add origin &lt;원격저장소 주소&gt;</code></p>
<ul>
<li>원격저장소 등록</li>
</ul>
<p><code>git clone &lt;저장소주소&gt; [새로운 폴더명]</code></p>
<ul>
<li>복제하려다 실패하는 대부분의 이유는 폴더명을 생략하면 자동으로 프로젝트 이름과 같은 이름의 폴더가 새로 생성되는데 보통 이름이 이미 존재할 경우라 그런다.</li>
<li>에러 fatal: destination path ‘폴더명’ already exist and is not an empty directory. </li>
</ul>
<hr>
<h4 id="12-2-커밋--히스토리-상태-보기">12-2. 커밋 / 히스토리 상태 보기</h4>
<p><code>git status</code></p>
<ul>
<li>현재 진행 상태 </li>
</ul>
<p><code>git log —oneline</code></p>
<ul>
<li>간단한 커밋해시와 제목만 보고 싶을때</li>
</ul>
<p><code>git log —oneline —graph —decorate</code></p>
<ul>
<li>HEAD와 관련된 커밋들을 조금 더 자세히 보고 싶을 때</li>
</ul>
<p><code>git log —oneline —graph —all —decorate</code></p>
<ul>
<li>모든 브랜치들을 보고 싶을때 사용하는 명령</li>
</ul>
<p><code>git log —oneline -n5</code></p>
<ul>
<li>내 브랜치의 최신 커밋 5개만 보고 싶을때 사용</li>
</ul>
<h5 id="git-blame">git blame</h5>
<blockquote>
<p>note 특정 파일의 수정 이력을 확인할 수 있다. 각 라인별로 누가, 언제 마지막으로 수정 했는지 알 수 있다.</p>
</blockquote>
<p><code>git blame test.txt</code></p>
<ul>
<li>test.txt 파일의 수정 이력을 확인</li>
</ul>
<p><code>git blame -L 5,10 test.txt</code></p>
<ul>
<li>test.txt 파일의 5부터 10번 라인까지만 확인</li>
</ul>
<p><code>git blame -C newTest.txt</code></p>
<ul>
<li>파일명이 변경 되었다면, 변경전의 파일명과 함께 확인</li>
</ul>
<p><code>git blame -w test.txt</code></p>
<ul>
<li>공백 변경을 무시</li>
</ul>
<hr>
<h4 id="12-3-branch">12-3. branch</h4>
<p><code>git branch</code></p>
<ul>
<li>현재 로컬 브랜치 목록 보기 </li>
</ul>
<p><code>git branch -r</code></p>
<ul>
<li>현재 원격 저장소 목록 보기 </li>
</ul>
<p><code>git checkout temp</code></p>
<ul>
<li>브랜치 이동  git checkout {새로운 로컬 Branch 이름}</li>
</ul>
<p><code>git checkout -b develop master</code></p>
<ul>
<li>master을 기준으로 로컬에 새로운 브랜치를 생성합니다</li>
</ul>
<p><code>git checkout -b  develop origin/develop</code></p>
<ul>
<li><p>브랜치 생성 및 체크아웃(이동)
원격 브런치가 이미 존재 할 경우 원격 브런치를 기준으로 로컬 브랜치를 만드는 방법 
checkout 명령에 -b 옵션을 넣으면 브랜치 작성과 체크아웃을 한꺼번에 실행 </p>
<p><code>git checkout -b {새로운 로컬 Branch 이름} {원격 저장소 별칭}/{원격 Branch 이름}</code></p>
</li>
</ul>
<p><code>git push origin develop</code></p>
<ul>
<li>local 브랜치를 remote로 push하기</li>
</ul>
<p><code>git pull origin master</code></p>
<ul>
<li>origin(원격)에서 가져오기</li>
</ul>
<p><code>git branch -m master mymaster</code></p>
<ul>
<li>브랜치이름 변경 git branch -m <code>[브랜치명] [새로운 브랜치명]</code></li>
</ul>
<pre><code>git branch -d mybranch
git push origin -d mybranch</code></pre><ul>
<li>mybranch 라는 브랜치 제거. 두번째 명령어는 삭제된 브렌치를 리모트 저장소에도 동기화 <blockquote>
<p>note : <code>git push origin -d mybranch</code> 삭제 명령 후에 git unable to delete remote ref does not exist 라는
메세지가 나온다면 remote 된 git 서버와의 최신 동기화가 이루어 지지 않아서 발생하는 문제이다.
깃허브나 비트버킷 사이트로 들어가서 정보를 조회해 보면 삭제된 것을 볼 수 있다. 
하지만 <code>git branch -r</code> 로 브랜치를 조회를 하면 삭제한 브랜치가 남아 있는 것을 볼 수 있을 것이다.
결론은 최신 동기화를 해주면 된다. <code>git fetch -p origin</code>  여기서 -p 옵션은 더 이상 존재하지 않는 remote 브랜치 정보는 삭제하는 것이다.</p>
</blockquote>
</li>
</ul>
<p><code>git fetch -p origin</code></p>
<ul>
<li>서버와 최신 정보 동기화 시키고 삭제된 브랜치 내역 제거 </li>
</ul>
<pre><code>git branch -D mybranch</code></pre><ul>
<li><code>-D</code> 옵션은 강제 삭제를 의미한다. 만약 머지 중이거나 수정 중인 상태라면 error 를 띄울텐데 그래도 상관없이 지운다면 해당 옵션으로 지우면 된다.</li>
</ul>
<hr>
<h4 id="12-4-스테이징-로컬-임시저장--및-커밋">12-4 스테이징( 로컬 임시저장 ) 및 커밋</h4>
<p><code>git add test.txt</code></p>
<ul>
<li>test.txt  를 스테이지에 저장.</li>
</ul>
<p><code>git add .</code></p>
<ul>
<li>폴더의 전체 변경 사항 지정 ( 현재 디렉토리의 모든 변경 내용을 스테이징 영역에 추가 )</li>
</ul>
<p><code>git add -A</code></p>
<ul>
<li>폴더의 전체 변경 사항 지정 ( 작업 디렉토리 내의 모든 변경 내용을 몽땅 스테이징 영역에 추가 )</li>
</ul>
<blockquote>
<p>note: </p>
<ul>
<li><code>git add -A</code>는 작업 디렉토리 상에 어디에 위치하든 항상 동일하게 모든 변경 내용을 스테이징으로 넘긴다. 
반면에 <code>git add .</code>는 명령어를 실행한 디렉토리 이하에서 발생한 변경 내용만 포함하며, 
해당 디렉토리 기준으로 상위 디렉토리의 변경 내용을 포함하지 않는다. 
만약에 <code>git add .</code>를 프로젝트 최상위 디렉토리에서 실행한다면 <code>git add -A</code>와 동일한 효과를 낸다.</li>
</ul>
</blockquote>
<p><code>git commit -m &#39;기록할 메세지&#39;</code></p>
<ul>
<li>입력한 메세지와 함께 커밋 </li>
</ul>
<p><code>git commit -am &#39;기록할 메세지&#39;</code></p>
<ul>
<li>스테이지와 커밋을 한번에 실행.</li>
</ul>
<p><code>git commit --amend</code></p>
<ul>
<li>이전 커밋에 변경사항을 추가할때 </li>
</ul>
<p><code>git log</code></p>
<ul>
<li>커밋한 결과 확인 ( 주의 - 모든 목록이 나온다 )</li>
</ul>
<p><code>git show</code></p>
<ul>
<li>최근 커밋 확인( 주의 - 변경 내역까지 다 나옴 )</li>
</ul>
<p><code>git show --stat</code> </p>
<ul>
<li>최근 커밋 요약해서 보기. ( 추천 )</li>
</ul>
<p><code>git log --graph</code></p>
<ul>
<li>에디터의 그래프 보듯 예쁘게 히스토리 보기.</li>
</ul>
<hr>
<h4 id="12-5-되돌리기">12-5 되돌리기.</h4>
<p>코드를 작성하다보면 잘못된 코드를 추가하거나 merge한 경우 이를 취소할때,</p>
<p>a. git reset 으로 취소( 단 push 이전 상태이여야 함 )</p>
<p><code>git reset</code></p>
<ul>
<li>add 한 파일 취소</li>
</ul>
<p><code>git reset --merge</code></p>
<ul>
<li>merge 한 코드 취소</li>
</ul>
<p>b.만약 commit만 취소하고, 작성한 코드는 남겨둘려면? reset –soft 명령어 사용</p>
<p><code>git reset --soft HEAD^</code></p>
<ul>
<li>commit 코드 되살리기</li>
</ul>
<p><code>git reset --hard HEAD^</code></p>
<ul>
<li>commit 하기 이전 코드로 돌아가기</li>
</ul>
<p><code>git rebase &lt;대상 브랜치&gt;</code></p>
<ul>
<li><p>내 브랜치의 커밋들을 대상 브랜치에 재배치 ( 커밋 히스토리를 하나로 합치기에 주의 - 그룹 리더가 책임지고 해야함.)</p>
<ul>
<li>git reset을 이용하여 작성한 코드를 초기화하고 서버로부터 다시 받아 오기.</li>
</ul>
</li>
</ul>
<p><code>git revert &lt;commit id&gt;</code></p>
<ul>
<li>commit을 유지하면서 내용을 Rollback하는 경우 ( 이미 push 하였을 경우 쓴다 )</li>
</ul>
<p><code>git checkout --&lt;파일이름&gt;</code></p>
<ul>
<li>로컬의 변경 내용을 되돌리기</li>
</ul>
<p><code>git stash</code>
-이미 자신의 작업 내역이 있고 변경 내역을 불러와 계속 작업을 이어 나갈 경우</p>
<p><code>git stash save &lt;저장할 목록 이름&gt;</code></p>
<ul>
<li>작업코드 임시저장하고 브랜치 바꾸기</li>
</ul>
<p><code>git stash pop</code></p>
<ul>
<li>마지막에 저장한 코드 불러오기.</li>
</ul>
<p><code>git stash apply</code></p>
<ul>
<li>가장 최근 저장한 stash 를 불러와 복원.</li>
</ul>
<p><code>git stash clear</code></p>
<ul>
<li>모든 stash 기록 제거.</li>
</ul>
<p><code>git stash list</code></p>
<ul>
<li>stash로 저장한 목록 보기.</li>
</ul>
<hr>
<p>.gitignore 에 제외할 파일 지정후 해당파일을 원격저장소 동기화하여 없애는 역활</p>
<p><code>git rm -r —cached</code></p>
<p><code>git add -A</code></p>
<p><code>git commit -m ‘기재할 내용’</code></p>
<p><code>git push</code></p>
<blockquote>
<p>note 
<code>—cached</code> 옵션은 git 저장소에만 파일을 지우고자 할때 적용
  <code>-r</code> 옵션은 재귀적 탐색 제거 허용</p>
</blockquote>
<hr>
<h5 id="단계별-취소">단계별 취소</h5>
<p><strong>1. 로컬 변경 취소</strong></p>
<p>git checkout .</p>
<blockquote>
<p>note 신규 추가한 파일에 관해서는 삭제되지 않으므로, 완전히 원래대로 되돌리려면 따로 삭제해야 한다.</p>
</blockquote>
<p><code>git clean -n</code></p>
<ul>
<li>git clean 으로 제거될 파일 미리보기</li>
</ul>
<p><code>git clean -f</code> </p>
<ul>
<li>전체 untracked files 제거</li>
</ul>
<p><code>git clean -f &lt;filename&gt;</code></p>
<ul>
<li>한 개의 untracked files 제거</li>
</ul>
<p><code>git clean -d -f</code></p>
<ul>
<li>전체 untracked files 및 디렉터리까지 삭제</li>
</ul>
<p><strong>2. add를 취소</strong></p>
<p><code>git reset</code></p>
<ul>
<li>전체 파일 add 취소</li>
</ul>
<p><code>git reset HEAD &lt;filename&gt;</code></p>
<ul>
<li>최신 커밋 / 스테이지 취소 </li>
</ul>
<p><strong>3. commit 취소</strong></p>
<p><code>git reset HEAD^</code></p>
<ul>
<li>최근 commit 취소 <code>git reset --mixed HEAD^</code> 와 동일 </li>
</ul>
<p><code>git reset --soft HEAD^</code></p>
<ul>
<li>commit 코드 되살리기( 코드는 살려두고 커밋 취소 )</li>
</ul>
<p><code>git reset --hard HEAD^</code></p>
<ul>
<li>commit 하기 이전 코드로 돌아가기( 복구 불가 )</li>
</ul>
<p><code>git reset HEAD~2</code></p>
<ul>
<li>마지막 2개의 commit 을 취소</li>
</ul>
<p><strong>4. push 취소</strong></p>
<p><code>git revert &lt;commit_Id&gt;</code>
<code>git push origin &lt;branch-name&gt;</code>
이것은 undo한다는 느낌 보다, 변경 지점을 추가 commit 하는 것.</p>
<p><strong>5. merge 취소 방식</strong> </p>
<p>a. git 머지(병합) 했더니 충돌. 편집해서 수정하지 않을 경우 한정</p>
<p><code>git merge --abort</code></p>
<ul>
<li>병합전의 상태로 되돌린다.</li>
</ul>
<p>b. git 머지 후 충돌해서 수정하려고 시도했지만, 중간에 그만두고 싶을때! 편집한 내용도 머지(병합)도 모두 취소.</p>
<p><code>git reset --hard HEAD</code></p>
<p>c. 머지(병합) 모두 완료 후. 근데 역시 되돌리고 싶을때. 
revert 커맨드를 사용하여 Merge commit 을 취소.
<code>git revert &lt;commit_Id&gt;</code></p>
<p>d. 머지(병합) 모두 완료 후 되돌리고 싶을때.( 추천하지 않음 - 이력이 남지 않는다. )
<code>git reset --hard ORIG_HEAD</code></p>
<ul>
<li>머지(병합)하기 전의 HEAD로 돌아갑니다. 이 방법은 한번 생긴 커밋을 취소하는 것. 이력이 남지 않는다.</li>
</ul>
<p>e. reset, revert 후 저장소 강제 업데이트 
<code>git push -f origin &lt;브랜치이름&gt;</code></p>
<h4 id="12-7-동기화">12-7 동기화</h4>
<pre><code>git fetch origin
git reset --hard origin/master</code></pre><ul>
<li><strong>로컬에 있는 모든 변경 내용과 확정본을 포기</strong>. 원격 저장소의 최신 이력을 가져오고
로컬 master브랜치의 상태를 가져온 최신이력으로 변경.</li>
</ul>
<p><code>git cherry-pick &lt;commit id&gt;</code></p>
<ul>
<li>다른 커밋 버전을 현재의 브렌치에 업데이트하기.</li>
</ul>
<p><code>git cherry-pick &lt;commit id&gt; -continue</code></p>
<ul>
<li>conflict 등으로 실패하는 경우 계속해서 해결하기 위한 방법을 찾는다.</li>
</ul>
<p><code>git cherry-pick &lt;commit id&gt; -n</code></p>
<ul>
<li>파일변경, 커밋은 하지 않는다.</li>
</ul>
<p><code>git cherry-pick &lt;commit id&gt; -quit</code></p>
<ul>
<li>실패하는 경우 더 진행하지 않고 현재 상태를 빠져나온다.</li>
</ul>
<p><code>git cherry-pick &lt;commit id&gt; -abort</code></p>
<ul>
<li>체리픽 이전 상태로 돌리고 취소한다.</li>
</ul>
<h4 id="12-8-git-협업을-위한-flow">12-8 git 협업을 위한 flow.</h4>
<ol>
<li>저장소와 자신의 로컬 연동. (git clone)</li>
</ol>
<ul>
<li>만약 최종 결정권자라면 원격 저장소생성하고 그 원격저장소와 로컬 연결. git remote</li>
</ul>
<ol start="2">
<li>develop 브랜치를 가져와 자신의 브랜치 로컬 및 원격저장소에 생성. <code>git checkout -b develop origin/develop</code>
( 최종 결정권자는 develop 브랜치가 없다면 생성. )</li>
<li>develop 에서 분리된 자신작업 공간 브랜치 생성 그리고 아래와 같은 작업순으로 이루어진다.</li>
</ol>
<ul>
<li>pull origin develop &gt; add &gt; commit &gt; push </li>
</ul>
<ol start="4">
<li>작업 완료 되면 pull request 요청 </li>
<li>최종 결정권자는 오픈된 pull request 사항을 체크 후 develop 에 merge 혹은 decline 시킨다.</li>
<li>최종 작업 마무리는  develop 의 모든 사항은 master 에 merge </li>
</ol>
<p><img src="./gitWorkFlow.jpg" alt="./gitWorkFlow.jpg"></p>
<h3 id="12-9-기타-주의-사항">12-9 기타 주의 사항.</h3>
<blockquote>
<p>note : package-lock.json </p>
<ul>
<li>package-lock.json 파일은 의존성 트리에 대한 정보를 가지고 있으며, 작성된 시점의 의존성 트리가 다시 생성될 수 있도록 보장해준다.</li>
<li>package-lock.json 파일은 저장소에 꼭 같이 커밋해야 한다.</li>
<li>package-lock.json 파일은 node_modules 없이 배포하는 경우 반드시 필요하다.</li>
</ul>
</blockquote>
<hr>
<h2 id="13-기타--오픈그래프--파비콘--아이콘-폰트-만들기-">13. 기타 ( 오픈그래프 / 파비콘 / 아이콘 폰트 만들기 )</h2>
<h3 id="1-오픈-그래프">1. 오픈 그래프</h3>
<ul>
<li>오픈그래프 프로토콜은 페이스북에서 처음 만들어졌으며, Dublin Core, link-rel canonical, Microformats, 그리고 RDFa로부터 영감을 받았다. 
오픈그래프는 어떤 HTML 문서의 메타정보를 쉽게 표시하기 위해서 메타정보에 해당하는 제목, 설명, 문서의 타입, 대표 URL 등 다양한 요소들에 대해서 사람들이 
통일해서 쓸 수 있도록 정의해놓은 프로토콜이며 페이스북에 의하여 기존의 다양한 메타 데이터 표기 방법을 참조하여 만들어졌다. 그 간편함으로 인하여 현재는 그 창시자인 페이스북은 물론이고, 네이버 블로그, 카카오톡 등에서도 널리 사용하고 있다.
미리보기를 통해 보는 제목, 설명, 이미지는 이렇게 HTML 문서의 head에 표기된 오픈그래프 프로토콜에 의해서 나타나고 있다. 그 구체적인 작동 원래는 아래와 같다.</li>
</ul>
<ol>
<li>사용자가 링크를 입력창에 입력.</li>
<li>페이스북, 네이버 블로그, 카카오톡은 입력창의 문자열이 “링크”라는 것을 파악한다. (흔히 말하는 정규표현식으로 해당 문자열이 링크라는 것을 알아낸다.)</li>
<li>링크라는 것이 파악되면 페이스북, 네이버 블로그, 카카오톡의 크롤러는 미리 그 웹사이트를 방문해서 HTML head의 오픈그래프(Open Graph) 메타 데이터를 긁어온다.</li>
<li>이중에서도 og:title, og:description, og:image 가 각각 제목, 설명, 이미지의 정보를 나타낸다.</li>
<li>그리고 그 정보를 바탕으로 미리보기 화면을 생성해주게 된다.</li>
</ol>
<p>아래는 예시 코드</p>
<pre><code>&lt;meta property=&quot;og:title&quot; content=&quot;MINTIT UX&quot;&gt;
&lt;meta property=&quot;og:url&quot; content=&quot;http://mintit.inition.kr/&quot;&gt;
&lt;meta property=&quot;og:description&quot; content=&quot;Used Mobile Phone Upcycling Service Design&quot;&gt;
&lt;meta property=&quot;og:image&quot; content=&quot;http://mintit.inition.kr/assets/images/mintit-sns2.png&quot;&gt;
&lt;meta property=&quot;og:type&quot; content=&quot;website&quot;&gt;
&lt;meta property=&quot;og:site_name&quot; content=&quot;MINTIT UX&quot;&gt;</code></pre><table>
<thead>
<tr>
<th align="left">Tag</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">og:url</td>
<td align="left">페이지의 표준 URL (데스크탑 URL)</td>
</tr>
<tr>
<td align="left">og:title</td>
<td align="left">콘텐츠 제목</td>
</tr>
<tr>
<td align="left">og:description</td>
<td align="left">콘텐츠 설명. 미리보기에서 제목 아래에 표시</td>
</tr>
<tr>
<td align="left">og:image</td>
<td align="left">콘텐츠를 공유 시 표시되는 이미지의 URL</td>
</tr>
<tr>
<td align="left">og:site_name</td>
<td align="left">웹 사이트의 이름 (주소 아님)</td>
</tr>
</tbody></table>
<blockquote>
<p>note : image size 는 800x800 혹은 270x270 이며</p>
<ul>
<li>보여주고자 하는 아이콘 및 텍스트는 가로 세로 중앙정렬로 배치 되어야 한다.</li>
</ul>
</blockquote>
<blockquote>
<p>note: 카카오 경우 아래와 같은 가이드로 진행됨( 디자인 가이드 )</p>
<ul>
<li>스크랩 이미지의 권장 크기는 800px x 800px (*실제 컨텐츠 사이즈가 아니라 캔버스 사이즈)</li>
<li>png 타입으로 15kb 내외</li>
<li>워드마크로 제작시 800px * 800px 이미지내 정중앙에 600px * 120px 크기의 이미지로 설정.</li>
<li>심볼로 만들때는 800px * 800px 이미지내 정중앙에 160px * 160px 크기의 이미지로 설정.</li>
</ul>
</blockquote>
<hr>
<h3 id="2-파비콘">2. 파비콘</h3>
<ul>
<li>파비콘은 웹페이지에 접속했을때, 상단 탭에 보여지는 아이콘을 일컫는다. 이 아이콘은 즐겨찾기에 웹페이지를 등록할때도 사용된다. 
웹사이트를 대표하는 로고(logo)의 개념과 비슷하며, 사이트의 성격을 드러내기도 한다.</li>
</ul>
<pre><code>&lt;!-- cdn 32x32 사이즈 .ico 파비콘 이미지 ( favicon.ico ) --&gt;
&lt;link rel=&quot;shortcut icon&quot; href=&quot;&quot;&gt;

&lt;!-- cdn 144x144 사이즈 .png 이미지 ( apple-touch-icon.png )--&gt;
&lt;link rel=&quot;apple-touch-icon&quot; href=&quot;&quot; sizes=&quot;144x144&quot;&gt;</code></pre><hr>
<h3 id="3-아이콘-폰트-만들기-svg-icon-font-">3. 아이콘 폰트 만들기( svg icon font )</h3>
<p><a href="https://icomoon.io/">https://icomoon.io/</a></p>
<blockquote>
<p>note ( 무료 svg icon font )</p>
<ul>
<li><a href="https://iconsvg.xyz/">https://iconsvg.xyz/</a></li>
<li><a href="https://basicons.xyz/">https://basicons.xyz/</a></li>
<li><a href="https://lucide.dev/">https://lucide.dev/</a></li>
<li><a href="https://icons8.com/line-awesome?ref=toools">https://icons8.com/line-awesome?ref=toools</a></li>
<li><a href="https://icons.theforgesmith.com/">https://icons.theforgesmith.com/</a></li>
<li><a href="https://tabler-icons.io/">https://tabler-icons.io/</a></li>
</ul>
</blockquote>
<ol>
<li>사이트 우측 상단에 IcoMoon App 버튼을 클릭</li>
</ol>
<p><img src="./docs/images/icomoon1.jpg" alt="1번"></p>
<hr>
<ol start="2">
<li>IcoMoon버튼을 눌러 아래와 같이 페이지가 이동되었다면<br>그림처럼 좌측 상단 Import Icons 를 눌러 제작한 svg 파일을 임포트 하면 된다.<br>( 만약 이미 아이콘 폰트를 발행한 적이 있으면서 환경 설정 json 파일을 가지고 있다면 svg 파일 대신 json 파일을 임포트 하면 된다. )  </li>
</ol>
<p><img src="./docs/images/icomoon2.jpg" alt="2번"></p>
<hr>
<ol start="3">
<li>svg파일을 올렸다면 아래 그림처럼 파일들이 보인다. 아이콘 폰트화 할 것들을 클릭해서 선택한다.<br>그리고 맨 하단 3번째 Generate Font 버튼을 클릭하여 생성시킨다.</li>
</ol>
<p><img src="./docs/images/icomoon3.jpg" alt="3번"></p>
<hr>
<ol start="4">
<li>아래 그림처럼 우측 하단에 Download 를 클릭하면 최종 생성된 아이콘 폰트 파일을 다운 받을 수 있다.<br>생성된 아이콘 및 web에서 css에 적용할 수 있겠끔 코드가 적혀 있다. 코드 값은 사용자에 맞게 수정할 수 있다.   </li>
</ol>
<p><img src="./docs/images/icomoon5.jpg" alt="5번"></p>
<hr>
<ol start="5">
<li>마지막으로 상단 우측에 프로젝트 네임이 보일 것이다.  &lt;br/&gt;   클릭해 보면 아래 그림처럼 프로젝트 리스트로 전환된다.<br>우측 중단에 Download 클릭하면 프로젝트 설정한 환경 세팅  json 파일을 다운로드 받을 수 있다.<br>그리고 다운로드 받는 위치를 잘 지정해야 한다.  svg 원본파일이 있는 폴더의 위치와 같은 경로로 지정해 주는 것이 가장 좋다.<br>이 환경 설정 json 파일 잘 갖고 있어야지만 다시 세팅하게 되는 불필요한 작업을 방지할 수 있다.<br>( json 파일 누락시 사이트에서 일일히 아이콘의 코드값을 입력해야 한다. )   </li>
</ol>
<p><img src="./docs/images/icomoon4.jpg" alt="4번"></p>
<hr>
<h2 id="14-프로젝트-초기-진행시-체크-사항">14. 프로젝트 초기 진행시 체크 사항</h2>
<ul>
<li><p><strong>font 종류</strong> ( 폰트 종류는 2개를 넘지 않는게 좋다.) </p>
</li>
<li><p><strong>font 범위</strong> ( 웹폰트 유무 체크 / 라이선스 체크 )</p>
</li>
<li><p>웹에선 <strong>font-size 가 11px 이하</strong>로 설정 되지 않게 해야 한다.</p>
</li>
<li><p><strong>웹접근성 체크</strong>( 접근성 LEVEL 체크 - 수준 A(웹 접근성이 요구하는 최소한의 수준), 수준 AA ) </p>
</li>
<li><p><strong>반응형</strong>( 태블릿까지 지원하는지 체크 ) / <strong>적응형</strong>( 태블릿까지 지원하는지 체크 ) 체크  - 모바일 버전까지 지원시 테스트 디바이스 체크 </p>
</li>
<li><p><strong>크로스브라우징 체크</strong> ( 크롬, 파이어폭스, 오페라, 엣지, IE 등 )</p>
</li>
<li><p><strong>웹퍼블리싱 / SPA</strong>( Single page application ) 둘 중 어느 타입의 프로젝트인지 체크 </p>
</li>
<li><p><strong>라이브러리 및 프레임워크</strong> 사용 체크 ( bootstrap, tailwindcss, jquery - 웹퍼블리싱만 하는 경우 / vue, react - spa 로 진행시 )</p>
</li>
<li><p><strong>컴포넌트 단위의 라이브러리/플러그인 호환성 및 버전 체크</strong>( date-picker, time-picker, calendar, rich text editor, chart 등)</p>
</li>
<li><p><strong>max-width</strong> / <strong>min-width</strong> 체크( 사이즈 수치값으로 1024 혹은 1280 로 작업. 그 결정하는 기준은 사이즈가 작은 랩탑까지도 지원해야 한다 했을 때 1024 을 선택 )</p>
</li>
<li><p>단색 위주의 아이콘이 많다면 <strong>svg icon font 제작</strong> / 아이콘 개수가 많은데 png 이미지로 해야 하는 경우는 <strong>image sprite 방식</strong>으로 제작 ( 만약 수정이 잦아지거나 운영 맡게 된다면 해당 기법은 패스 )</p>
</li>
<li><p>간단하게 sprite image 제작 <a href="https://spritegen.website-performance.org/">image sprite 제작 바로가기</a></p>
</li>
</ul>
<hr>
<h2 id="15-vue2x--간단-정리">15. vue2.x  간단 정리</h2>
<h3 id="1-컴포넌트">1. 컴포넌트</h3>
<p>Vue.component(‘컴포넌트 이름’, { } );</p>
<pre><code>&lt;body&gt;
&lt;div id=&quot;app&quot;&gt;
  &lt;mycomp&gt;&lt;/mycomp&gt; 
&lt;/div&gt;

&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.16/vue.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    Vue.component(&#39;mycomp&#39;, {
          template:`&lt;div&gt;mycomp 컴포넌트&lt;/div&gt;`
     } );
    new Vue({
       el:&#39;#app&#39;
    });
&lt;/script&gt;
&lt;/body&gt;</code></pre><p><strong>상*하위 컴포넌트 관계</strong></p>
<ul>
<li>컴포넌트는 각각 고유한 유효범위를 갖고 있기 때문에 직접 다른 컴포넌트의 값을 참조할 수 없다. 따라서 뷰에서 정한 데이터 전달 방법을 따라야 한다.</li>
</ul>
<p><strong>기본적인 데이터 전달 방법</strong></p>
<p><strong>1. 상위에서 &gt; 하위로는 props</strong> 라는 속성으로 값을 전달.</p>
<pre><code>&lt;child v-bind:props 속성이름=&quot;상위 컴포넌트의 data속성&quot;&gt;&lt;/child&gt;</code></pre><p><strong>2. 뷰는 단방향 데이터 바인딩</strong>을 구현하기에 <strong>하위에서 &gt; 상위로는 이벤트 버스</strong>를 이용하여 데이터를 전달한다.</p>
<pre><code>this.$emit(&#39;이벤트명&#39;); //이벤트 발생시킴.

&lt;child v-on:이벤트명=&quot;상위 컴포넌트의 메서드명&quot;&gt;&lt;/child&gt; // v-on으로 이벤트 수신.</code></pre><p><strong>3. 관계 없는 컴포넌트 간 통신( 이벤트 버스)</strong> - 지정한 2개의 컴포넌트 간에 데이터를 주고 받을 수 있다.</p>
<pre><code>//이벤트 버스 인스턴스 1개 생성.

var eventBus=new Vue();

//이벤트를 보내는 컴포넌트

methods:{

메서드명:function(){

eventBus.$emit(&#39;이벤트명&#39;, 데이터);

}

//이벤트를 받는 컴포넌트

methods:{

created:function(){

eventBus.$on(&#39;이벤트명&#39;, function(데이터){

.......

}</code></pre><hr>
<p><strong>클래스 / 스타일 바인딩</strong></p>
<p><strong>a.객체 구문</strong></p>
<p><strong>- 인라인 방식</strong></p>
<ul>
<li>active, text-danger 클래스가 적용되려면 true가 할당되면 된다.</li>
</ul>
<pre><code>&lt;div class=&quot;static&quot;
  v-bind:class=&quot;{ active: isActive, &#39;text-danger&#39;: hasError }&quot;&gt;&lt;/div&gt;</code></pre><pre><code>data: {
  isActive: true,
  hasError: false
}</code></pre><p><strong>- 객체 대입 방식</strong></p>
<pre><code>&lt;div v-bind:class=&quot;classObject&quot;&gt;&lt;/div&gt;</code></pre><pre><code>data: {
  classObject: {
    active: true,
    &#39;text-danger&#39;: false
  }
}</code></pre><p><strong>- 객체 (함수리턴) 대입 방식</strong></p>
<pre><code>&lt;div v-bind:class=&quot;classObject&quot;&gt;&lt;/div&gt;</code></pre><pre><code>data: {
  isActive: true,
  error: null
},
computed: {
  classObject() {
    return {
      active: this.isActive &amp;&amp; !this.error,
      &#39;text-danger&#39;: this.error &amp;&amp; this.error.type === &#39;fatal&#39;
    }
  }
}</code></pre><p><strong>b.배열 구문</strong></p>
<ul>
<li>errorClass는 항상 적용되고 isActive 가 true 일 경우에만 active 적용.</li>
</ul>
<pre><code>&lt;div v-bind:class=&quot;[{ active: isActive }, errorClass]&quot;&gt;&lt;/div&gt;</code></pre><h3 id="2-라우터--http">2. 라우터 &amp; HTTP</h3>
<ul>
<li>터미널에 아래와 같은 구문으로 라우터를 추가
(TypeScript 사용자는 <a href="mailto:vue-router@3.0">vue-router@3.0</a>+와 <a href="mailto:vue@2.5">vue@2.5</a>+를 사용 )</li>
</ul>
<pre><code>npm install vue-router</code></pre><p>설치한 라우터 사용(라우터를 명시적 추가 및 선언 )</p>
<pre><code>import Vue from &#39;vue&#39;
import VueRouter from &#39;vue-router&#39;

Vue.use(VueRouter)</code></pre><pre><code>const User = {
  template: &#39;&lt;div&gt;User&lt;/div&gt;&#39;
}

const router = new VueRouter({
  routes: [
    // 동적 세그먼트는 콜론으로 시작합니다.
    { path: &#39;/user/:id&#39;, component: User }
  ]
})</code></pre><p>동적 세그먼트는 콜론 : 으로 표시한다.</p>
<p>라우트가 이리하면 동적 세그먼트의 값은 모든 컴포넌트에서 this.$route.params 로 표신된다.</p>
<pre><code>const User = {
  template: &#39;&lt;div&gt;User {{ $route.params.id }}&lt;/div&gt;&#39;
}</code></pre><p>동일한 라우트에 여러 동적 세그먼트를 가질 수 있으며, $route.params 의 해당 필드에 매핑된다.</p>
<p>/user/:username –&gt;/user/tom –&gt; { username:’tom’}</p>
<p>$route.params 외에도 $route 객체는 <strong>$route.query</strong> (URL에 쿼리가 있는 경우), $route.hash 등의 유용한 정보를 제공한다.</p>
<p>동일한 컴포넌트의 params 변경 사항에 반응하려면 $route 객체를 watch 로 체크할 수 있다.</p>
<pre><code>const User = {
  template: &#39;...&#39;,
  watch: {
    &#39;$route&#39; (to, from) {
      // 경로 변경에 반응하여...
    }
  }
}</code></pre><p>혹은 beforeRouteUpdate 가드를 사용 할 수 있다.</p>
<pre><code>const User = {
  template: &#39;...&#39;,
  beforeRouteUpdate (to, from, next) {
    // react to route changes...
    // don&#39;t forget to call next()
  }
}</code></pre><h3 id="라우터-가드">라우터 가드</h3>
<ul>
<li>아래 befoeEnter 는 각 라우트에 해당하는 개별 라우트 가드이다.</li>
</ul>
<pre><code>const router = new VueRouter({
  routes: [
    {
      path: &#39;/foo&#39;,
      component: Home,
      beforeEnter: (to, from, next) =&gt; {
        // ...
      }
    }
  ]
})</code></pre><p>네비게이션이 트리거될 때마다 가드가 작성 순서에 따라 호출되기 전의 모든 경우에 발생한다.</p>
<p>가드는 비동기식으로 실행 될 수 있으며 네비게이션은 모든 훅이 해결되기 전까지 <strong>보류 중</strong> 으로 진행된다.</p>
<p>모든 가드 기능은 세 가지 전달인자를 받는다.</p>
<ul>
<li><strong>to: 라우트</strong>: 대상 Route객체로 이동</li>
<li><strong>from: 라우트</strong>: 현재 라우트로 오기전 라우트</li>
<li><strong>next: 함수</strong>: 이 함수는 <strong>훅을 해결하기 위해</strong> 호출 되어야 한다.</li>
<li><strong>next()</strong>: 파이프라인의 다음 훅으로 이동. 훅이 없는 경우 네비게이션은 <strong>승인</strong>.</li>
<li><strong>next(false)</strong>: 현재 네비게이션을 중단. 브라우저 URL 이 변경되면(사용자 또는 뒤로 버튼을 통해 수동으로 변경됨) from 경로의 URL 로 재설정된다.</li>
<li><strong>next(‘/‘) 또는 next({ path: ‘/‘ })</strong>: 다른 위치로 리디렉션.</li>
<li><strong>next(error)</strong>: (2.4.0 이후 추가) next 에 전달된 인자가 Error 의 인스턴스이면 탐색이 중단되고 router.onError() 를 이용해 등록 된 콜백에 에러가 전달.</li>
</ul>
<h3 id="axios">axios</h3>
<p>vue-resource 라고는 있지만 더이상 업데이트 되지 않고 있고 해결되지 않은 이슈도 많다고 해서
공식 홈페이지에선 axios를 더 추천함. 터미널에서 아래의 코드로 설치.</p>
<pre><code>npm install --save axios</code></pre><p>전역으로 사용하려면 Vue의 프로토타입에 추가해서 사용하면 된다.</p>
<pre><code>import Vue from &#39;vue&#39;
import App from &#39;./App&#39;
import axios from &#39;axios&#39;

Vue.prototype.$http=axios

new Vue({
  el:&#39;#app&#39;,
  template:&#39;&lt;App /&gt;&#39;,
  components:{ App }
  })</code></pre><p>Request Method</p>
<p><strong>axios.request(config)</strong></p>
<p><strong>axios.get(url[, config])</strong></p>
<p><strong>axios.delete(url[, config])</strong></p>
<p><strong>axios.head(url[, config])</strong></p>
<p><strong>axios.options(url[, config])</strong></p>
<p><strong>axios.post(url[, data[, config]])</strong></p>
<p><strong>axios.put(url[, data[, config]])</strong></p>
<p><strong>axios.patch(url[, data[, config]])</strong></p>
<p>기본 사용법</p>
<pre><code>const axios = require(&#39;axios&#39;);

// Make a request for a user with a given ID
axios.get(&#39;/user?ID=12345&#39;)
  .then(function (response) {
    // handle success
    console.log(response);
  })
  .catch(function (error) {
    // handle error
    console.log(error);
  })
  .then(function () {
    // always executed
  });

// Optionally the request above could also be done as
axios.get(&#39;/user&#39;, {
    params: {
      ID: 12345
    }
  })
  .then(function (response) {
    console.log(response);
  })
  .catch(function (error) {
    console.log(error);
  })
  .then(function () {
    // always executed
  });  

// Want to use async/await? Add the `async` keyword to your outer function/method.
async function getUser() {
  try {
    const response = await axios.get(&#39;/user?ID=12345&#39;);
    console.log(response);
  } catch (error) {
    console.error(error);
  }
}</code></pre><h4 id="동시요청-수행">동시요청 수행</h4>
<pre><code>function getUserAccount() {
  return axios.get(&#39;/user/12345&#39;);
}

function getUserPermissions() {
  return axios.get(&#39;/user/12345/permissions&#39;);
}

axios.all([getUserAccount(), getUserPermissions()])
  .then(axios.spread(function (acct, perms) {
    // Both requests are now complete
  }));</code></pre><h4 id="axios-api">axios API</h4>
<pre><code>// Send a POST request
axios({
  method: &#39;post&#39;,
  url: &#39;/user/12345&#39;,
  data: {
    firstName: &#39;Fred&#39;,
    lastName: &#39;Flintstone&#39;
  }
});

// GET request for remote image
axios({
  method:&#39;get&#39;,
  url:&#39;http://bit.ly/2mTM3nY&#39;,
  responseType:&#39;stream&#39;
})
  .then(function (response) {
    response.data.pipe(fs.createWriteStream(&#39;ada_lovelace.jpg&#39;))
  });</code></pre><h4 id="전역적-axios-지정">전역적 axios 지정</h4>
<pre><code>axios.defaults.baseURL = &#39;https://api.example.com&#39;;
axios.defaults.headers.common[&#39;Authorization&#39;] = AUTH_TOKEN;
axios.defaults.headers.post[&#39;Content-Type&#39;] = &#39;application/x-www-form-urlencoded&#39;;</code></pre><h4 id="interceptors">interceptors</h4>
<p>-요청 또는 응답이 처리되거나 처리되기 전에 해당요청 또는 응답을 인터셉트 할 수 있다.</p>
<pre><code>//요청에 대한 interceptor 추가
axios.interceptors.request.use(function (config) {
    // ~ 요청 전에 무언가 보낼 코드 부분 ~
    return config;
  }, function (error) {
     //에러 응답
    return Promise.reject(error);
  });

//응답에 대한 interceptor 추가
axios.interceptors.response.use(function (response) {
    // ~ 응답에 대한 무언가의 코드 부분 ~
    return response;
  }, function (error) {
    //에러 응답
    return Promise.reject(error);
  });</code></pre><h3 id="3-뷰-템플릿">3. 뷰 템플릿</h3>
<ul>
<li></li>
<li>디렉티브</li>
</ul>
<p><strong>1. v-bind</strong></p>
<pre><code>&lt;!-- 전체 문법 --&gt;
&lt;a v-bind:href=&quot;url&quot;&gt; ... &lt;/a&gt;
&lt;!-- 약어 --&gt;
&lt;a :href=&quot;url&quot;&gt; ... &lt;/a&gt;</code></pre><p><strong>2. v-on</strong></p>
<pre><code>&lt;!-- 전체 문법 --&gt;
&lt;a v-on:click=&quot;doSomething&quot;&gt; ... &lt;/a&gt;
&lt;!-- 약어 --&gt;
&lt;a @click=&quot;doSomething&quot;&gt; ... &lt;/a&gt;</code></pre><p><strong>3. <strong>v-for</strong></strong></p>
<p><strong>v-for 디렉티브를 사용하여 배열을 기반으로 리스트 렌더링.</strong></p>
<p><strong>형식 - item in items</strong></p>
<p><strong>items 는 원본 데이터 배열</strong></p>
<p><strong>item 은 반복되는 배열 엘리먼트의 **별칭</strong>.**</p>
<pre><code>&lt;ul id=&quot;example-2&quot;&gt;
  &lt;li v-for=&quot;(item, index) in items&quot;&gt;
    {{ parentMessage }} - {{ index }} - {{ item.message }}
  &lt;/li&gt;
&lt;/ul&gt;</code></pre><pre><code>var example2 = new Vue({
  el: &#39;#example-2&#39;,
  data: {
    parentMessage: &#39;Parent&#39;,
    items: [
      { message: &#39;Foo&#39; },
      { message: &#39;Bar&#39; }
    ]
  }
})</code></pre><p>키에 대한 두번째 전달 인자를 제공.</p>
<pre><code>&lt;div v-for=&quot;(value, key) in object&quot;&gt;
  {{ key }}: {{ value }}
&lt;/div&gt;</code></pre><p><strong>4. v-for에서 :key ( 2.2.0 이상에서 v-for는 key 가 필수. )</strong></p>
<p>Vue가 각 노드의 ID를 추적하고 기존 엘리먼트를 재사용하고 재정렬할 수 있도록d
힌트를 제공하려면 각 항목에 고유한 key 속성을 제공. <strong>(key 에 대한 이상적인 값은 각 항목의 고유한 ID. )</strong></p>
<pre><code>&lt;div v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt;
  &lt;!-- content --&gt;
&lt;/div&gt;</code></pre><p>반복되는 DOM 내용이 단순하지 않거나 의도적인 성능 향상을 위해 기본 동작에 의존하지 않는한 가능하면
언제나 v-for에 key 를 추가하는 것이 좋다. key 는 Vue 가 노드를 식별하는 일반적인 메커니즘이기 때문에
v- for 와 특별히 연관되지 않는 다른 용도로도 사용된다.</p>
<ul>
<li>데이터 바인딩</li>
</ul>
<p>템플릿 문법 - {{ }}</p>
<h3 id="4-상태관리-vuexstore">4. 상태관리 Vuex.Store</h3>
<pre><code>import Vuex from &#39;vuex&#39;

const store = new Vuex.Store({ ...options })</code></pre><h4 id="vuexstore-생성자-옵션">Vuex.Store 생성자 옵션</h4>
<h4 id="state">state</h4>
<ul>
<li>자료형: Object | Function 오브젝트를 반환하는 함수를 전달하면, 반환된 오브젝트가 루트 상태로 사용.이것은 모듈 재사용을 위해 상태 객체를 재사용하고자 할 때 유용하다.</li>
<li>Vuex 저장소의 루트 상태 객체.</li>
</ul>
<h4 id="mutations">mutations</h4>
<ul>
<li>자료형: { [type: string]: Function }(모듈에 정의 된 경우 모듈 로컬 상태가 된다). 두 번째 payload 전달인자가 있으면 처리.</li>
<li>저장소에 변이를 등록. 핸들러 함수는 항상 첫 번째 전달인자로 state 를 받는다</li>
</ul>
<h4 id="actions">actions</h4>
<p>- 자료형: { [type: string]: Function }</p>
<ul>
<li>저장소에 액션을 등록한다. 핸들러 함수는 다음 속성을 노출하는 context 객체를 받는다.</li>
</ul>
<pre><code>{
  state,      // store.state와 같습니다. 또는 모듈에 있는 경우 로컬 상태
  rootState,  // store.state와 같습니다. 모듈 안에만 존재합니다
  commit,     // store.commit와 같습니다.
  dispatch,   // store.dispatch와 같습니다.
  getters,    // store.getters와 같습니다. 또는 모듈에 있는 로컬 getters
  rootGetters // store.getters와 같습니다. 모듈 안에만 존재합니다
}</code></pre><p>두 번째 payload 전달인자가 있으면 처리한다.</p>
<h5 id="컴포넌트-바인딩-헬퍼--반복적이고-복잡한-코드선언-입력을-간소화-시킨다-">컴포넌트 바인딩 헬퍼 ( 반복적이고 복잡한 코드선언 입력을 간소화 시킨다 )</h5>
<p><strong>mapState</strong>(namespace?: string, map: Array&lt;string&gt; | Object&lt;string | function&gt;): Object</p>
<p>컴포넌트가 여러 저장소 상태 속성이나 getter 를 사용해야하는 경우 계산된 속성을 모두 선언하면 반복적이고 장황해진다.</p>
<p>이를 처리하기 위해 <strong>계산된 getter 함수를 생성하는</strong> <strong>mapState 헬퍼를 사용하여 키 입력을 줄일 수 있다.</strong></p>
<p>첫번째 인자값에 namespace는 타입이 string으로써 ?로 기재된 즉, <strong>optional 파라미터</strong> 타입이기에 생략 혹은 호출할 수 있다.</p>
<p>두번째 인자값은 <strong>유니언타입</strong>( let c = a | b  즉 c는 a또는 b 이다. )으로써 Array 혹은 오브젝트이다.</p>
<p>오브젝트 내부 속성들 타입도 유니언타입으로써 string 혹은 함수가 될 수 있다.</p>
<p><strong>mapMutations</strong>(namespace?: string, map: Array&lt;string&gt; | Object&lt;string | function&gt;): Object</p>
<p>변이를 커밋하는 컴포넌트 메소드 옵션을 만든다.</p>
<p>첫번째인자값은 string 타입의 namespace가 될 수 있다. (<strong>optional 파라미터</strong>타입이기에 생략 혹은 호출할 수 있다. )</p>
<p>두번째 인자값은<strong>유니언타입</strong>(let c = a | b 즉 c는 a또는 b 이다. )으로써 Array 혹은 오브젝트이다.</p>
<p>오브젝트 내부 속성들 타입도 유니언타입으로써 string 혹은 함수[ <strong>function(commit: function, …args: any[])</strong> ]가 될 수 있다.</p>
<h3 id="5-트랜지션">5. 트랜지션</h3>
<p>Vue 는 트랜지션 래퍼 컴포넌트를 제공하므로 다음과 같은 상황에서 모든 엘리먼트 또는</p>
<p>컴포넌트에 대한 진입 / 진출 트랜지션을 추가 할 수 있다.</p>
<ol>
<li>조건부 렌더링 (v-if 사용)</li>
<li>조건부 출력 (v-show 사용)</li>
<li>동적 컴포넌트</li>
<li>컴포넌트 루트 노드</li>
</ol>
<p>트랜지션 클래스</p>
<p>진입 : v-enter-active(v-enter + v-enter-to )</p>
<p>진출 : v-leave-active(v-leave + v-leave-to )</p>
<ul>
<li><p><strong>v-enter</strong>: enter 의 시작 상태. 엘리먼트가 삽입되기 전에 적용되고 한 프레임 후에 제거.</p>
</li>
<li><p><strong>v-enter-active</strong>: enter 에 대한 활성 및 종료 상태. 엘리먼트가 삽입되기 전에 적용. 트랜지션 / 애니메이션이 완료되면 제거.</p>
</li>
<li><p><strong>v-enter-to</strong>: <strong>2.1.8 이상 버전에서 지원합니다.</strong> 진입 상태의 끝에서 실행. 엘리먼트가 삽입된 후 (동시에 v-leave 가 제거됨), 트랜지션/애니메이션이 끝나면 제거되는 하나의 프레임을 추가.</p>
</li>
<li><p><strong>v-leave</strong> : leave 를 위한 시작 상태. 진출 트랜지션이 트리거 될 때 적용되고 한 프레임 후에 제거</p>
</li>
<li><p><strong>v-leave-active</strong>: leave 에 대한 활성 및 종료 상태. 진출 트랜지션이 트리거되면 적용되고 트랜지션 / 애니메이션이 완료되면 제거.</p>
</li>
<li><p><strong>v-leave-to</strong>: <strong>2.1.8 이상 버전에서 지원합니다.</strong>  진출 상태의 끝에서 실행. 진출 트랜지션이 트리거되고 (동시에 v-leave 가 제거됨), 트랜지션/애니메이션이 끝나면 제거되는 하나의 프레임을 추가.</p>
</li>
</ul>
<p>여기서 v-접두어는 이름없이 &lt;transition&gt;엘리먼트를 사용할 때의 기본값이다.</p>
<p>예를 들어&lt;transition name = &quot;my-trans&quot;&gt;을 사용하면 v-enter클래스는 my-trans-enter 가 됩니다.</p>
<p>v-enter-active 와v-leave-active 는 입/출력 트랜지션을 위한 다른 easing curve를 지정할 수있는 기능을 제공한다.</p>
<pre><code>&lt;div id=&quot;example-1&quot;&gt;
  &lt;button @click=&quot;show = !show&quot;&gt;
    Toggle render
  &lt;/button&gt;
  &lt;transition name=&quot;slide-fade&quot;&gt;
    &lt;p v-if=&quot;show&quot;&gt;hello&lt;/p&gt;
  &lt;/transition&gt;
&lt;/div&gt;</code></pre><pre><code>new Vue({
  el: &#39;#example-1&#39;,
  data: {
    show: true
  }
})</code></pre><pre><code>/* 애니메이션 진입 및 진출은 다른 지속 시간 및 */
/* 타이밍 기능을 사용할 수 있습니다. */
.slide-fade-enter-active {
  transition: all .3s ease;
}
.slide-fade-leave-active {
  transition: all .8s cubic-bezier(1.0, 0.5, 0.8, 1.0);
}
.slide-fade-enter, .slide-fade-leave-to{
  transform: translateX(10px);
  opacity: 0;
}</code></pre><p>참고: <a href="https://kr.vuejs.org/v2/guide/"> https://kr.vuejs.org/v2/guide/</a>   &lt;br/&gt;</p>
<p><a href="https://vuex.vuejs.org/kr/api/">https://vuex.vuejs.org/kr/api/</a></p>
<hr>
<h2 id="15-vue3x--간단-정리">15. vue3.x  간단 정리</h2>
<h3 id="script-setup-사용-ts-방식"><code>&lt;script setup&gt;</code> 사용, ts 방식</h3>
<ol>
<li>템플릿 문법</li>
</ol>
<ul>
<li>여러 속성을 동적으로 바인딩</li>
</ul>
<pre><code>const objectOfAttrs = {
  id: &#39;container&#39;,
  class: &#39;wrapper&#39;
}</code></pre><pre><code>&lt;div v-bind=&quot;objectOfAttrs&quot;&gt;&lt;/div&gt;</code></pre><ul>
<li>단축 문법
<code>&lt;div :id=&quot;dynamicId&quot;&gt;&lt;/div&gt;</code></li>
</ul>
<hr>
<ol start="2">
<li>Props</li>
</ol>
<ul>
<li><p>문법 제한# 
올바른 런타임 코드를 생성하려면 defineProps() 의 제너릭 전달인자가 다음 중 하나를 선택.</p>
<ul>
<li><p>객체 리터럴 타입:</p>
<pre><code>
defineProps&lt;{ /*... */ }&gt;()
</code></pre></li>
<li><p>동일한 파일에 있는 인터페이스 또는 객체 리터럴 타입에 대한 참조:</p>
<pre><code>
interface Props {/* ... */}
defineProps&lt;Props&gt;()
</code></pre></li>
</ul>
</li>
</ul>
<blockquote>
<p>note : defineProps 의 제네릭 전달인자는 가져온 타입을 사용 할 수 없다</p>
</blockquote>
<pre><code>import { Props } from &#39;./other-file&#39;

// 지원하지 않음
defineProps&lt;Props&gt;()</code></pre><blockquote>
<p>note: 해결책 -&gt; 컴파일러 매크로 withDefaults </p>
</blockquote>
<pre><code>export interface Props {
  msg?: string
  labels?: string[]
}

const props = withDefaults(defineProps&lt;Props&gt;(), {
  msg: &#39;hello&#39;,
  labels: () =&gt; [&#39;one&#39;, &#39;two&#39;]
})</code></pre><hr>
<ol start="3">
<li>컴포넌트 Emits 작성</li>
</ol>
<pre><code>&lt;script setup lang=&quot;ts&quot;&gt;
// runtime
// 런타임
const emit = defineEmits([&#39;change&#39;, &#39;update&#39;])

// type-based
// 타입기반
const emit = defineEmits&lt;{
  (e: &#39;change&#39;, id: number): void
  (e: &#39;update&#39;, value: string): void
}&gt;()
&lt;/script&gt;</code></pre><hr>
<ol start="4">
<li>ref()에 타입 적용하기</li>
</ol>
<ul>
<li>Ref 타입을 사용:</li>
</ul>
<pre><code>import { ref } from &#39;vue&#39;
import type { Ref } from &#39;vue&#39;

const year: Ref&lt;string | number&gt; = ref(&#39;2020&#39;)

year.value = 2020 // ok!</code></pre><ul>
<li>ref() 를 호출할 때 제너릭 전달인자를 전달:</li>
</ul>
<pre><code>import { ref } from &#39;vue&#39;
const year = ref&lt;string | number&gt;(&#39;2020&#39;)

year.value = 2020 // ok!</code></pre><blockquote>
<p>note : 제네릭 형식 타입를 지정하지만 초기 <strong>값을 생략하면 결과 타입은 undefined</strong> 를 포함하는 유니온 타입된다.</p>
</blockquote>
<pre><code>// 추론된 타입: Ref&lt;number | undefined&gt;
const n = ref&lt;number&gt;()</code></pre><hr>
<ol start="5">
<li>reactive()에 타입 지정하기</li>
</ol>
<ul>
<li>전달인자에서 타입을 암시적으로 추론: </li>
</ul>
<pre><code>import { reactive } from &#39;vue&#39;
// inferred type: { title: string }
// 추론된 타입: { title: string }
const book = reactive({ title: &#39;Vue 3 Guide&#39; })</code></pre><ul>
<li>명시적으로 입력하기 위해 인터페이스를 사용:</li>
</ul>
<pre><code>import { reactive } from &#39;vue&#39;

interface Book {
  title: string
  year?: number
}

const book: Book = reactive({ title: &#39;Vue 3 Guide&#39; })</code></pre><blockquote>
<p>note: 중첩된 ref unwrapping 을 처리하는 반환 타입이 제네릭 인자 타입과 다르기 때문에 reactive() 의 제네릭 전달인자는 사용하지 않는 것이 좋다.
reactive&lt;Book&gt;({ title: ‘Vue 3 Guide’ })  - X </p>
</blockquote>
<hr>
<ol start="6">
<li>계산된 속성( computed ) / computed()에 타입 지정하기</li>
</ol>
<ul>
<li>computed() 는 getter 의 반환 값을 기반으로 해당 타입을 추론:</li>
</ul>
<pre><code>import { ref, computed } from &#39;vue&#39;

const count = ref(0)

// 추론된 타입: ComputedRef&lt;number&gt;
const double = computed(() =&gt; count.value * 2)

// =&gt; TS Error: Property &#39;split&#39; does not exist on type &#39;number&#39;
const result = double.value.split(&#39;&#39;)</code></pre><ul>
<li>제네릭 인자를 통해 명시적으로 타입을 지정: </li>
</ul>
<pre><code>const double = computed&lt;number&gt;(() =&gt; {
  // type error if this doesn&#39;t return a number
})</code></pre><hr>
<ol start="7">
<li>이벤트 핸들러에 타입 지정</li>
</ol>
<pre><code>&lt;script setup lang=&quot;ts&quot;&gt;
function handleChange(event: Event) {
  console.log((event.target as HTMLInputElement).value)
}
&lt;/script&gt;

&lt;template&gt;
  &lt;input type=&quot;text&quot; @change=&quot;handleChange&quot; /&gt;
&lt;/template&gt;</code></pre><hr>
<ol start="8">
<li>Provide / Inject 에 타입 지정하기</li>
</ol>
<ul>
<li>provide 및 inject은 일반적으로 별도의 컴포넌트에서 수행된다. 
inject 된 값을 적절하게 입력하기 위해 Vue는 Symbol 을 확장하는 제네릭 타입인 InjectionKey 인터페이스를 제공한다. 
provider와 consumer 간에 주입된 값의 타입을 동기화하는 데 사용할 수 있다:</li>
</ul>
<pre><code>import { provide, inject } from &#39;vue&#39;
import type { InjectionKey } from &#39;vue&#39;

const key = Symbol() as InjectionKey&lt;string&gt;
provide(key, &#39;foo&#39;) // 문자열이 아닌 값을 제공하면 에러가 발생합니다
const foo = inject(key) // type of foo: string | undefined</code></pre><ul>
<li>여러 컴포넌트에서 가져올 수 있도록 injection key를 별도의 파일에 배치하는 것이 좋다. </li>
<li>문자열 injection key를 사용할 때 주입된 값의 타입은 unknown 이 되므로, 제너릭 타입 전달인자를 통해 명시적으로 선언해야 한다.</li>
</ul>
<pre><code>const foo = inject&lt;string&gt;(&#39;foo&#39;) // type: string | undefined</code></pre><ul>
<li>주입된 값은 여전히 undefined 일 수 있습니다. provider가 런타임에 이 값을 제공할 것이라는 보장이 없기 때문. 
undefined 타입은 기본값을 제공하여 제거할 수 있다:</li>
</ul>
<pre><code>const foo = inject&lt;string&gt;(&#39;foo&#39;, &#39;bar&#39;) // type: string</code></pre><ul>
<li>값이 항상 제공된다고 확신하는 경우 값을 강제로 캐스팅할 수도 있다.</li>
</ul>
<pre><code>const foo = inject(&#39;foo&#39;) as string</code></pre><hr>
<ol start="9">
<li>템플릿 Refs 에 타입 지정하기</li>
</ol>
<ul>
<li>템플릿 refs는 명시적인 제네릭 타입 전달인자와 초기 값 null 로 생성되어야 합니다:</li>
<li>타입 안전을 위해 el.value 에 접근할 때 옵셔널 체이닝 또는 타입 가드를 사용해야 한다. </li>
<li>이는 컴포넌트가 마운트될 때까지 초기 ref 값이 null 이고 참조된 ref 가 v-if 에 의해 마운트 해제된 경우에도 null 로 설정될 수 있기 때문.</li>
</ul>
<pre><code>&lt;script setup lang=&quot;ts&quot;&gt;
import { ref, onMounted } from &#39;vue&#39;

const el = ref&lt;HTMLInputElement | null&gt;(null)

onMounted(() =&gt; {
  el.value?.focus()
})
&lt;/script&gt;

&lt;template&gt;
  &lt;input ref=&quot;el&quot; /&gt;
&lt;/template&gt;</code></pre><hr>
<ol start="10">
<li>컴포넌트 템플릿 Template Refs 에 타입 지정</li>
</ol>
<ul>
<li>때로는 public 메서드를 호출하기 위해 자식 컴포넌트에 대한 템플릿 ref에 어노테이션이 필요 할 수 있다. </li>
<li>예를 들어, 모달을 여는 메서드가 있는 MyModal 자식 컴포넌트가 있다:</li>
</ul>
<pre><code>&lt;!-- MyModal.vue --&gt;
&lt;script setup lang=&quot;ts&quot;&gt;
import { ref } from &#39;vue&#39;

const isContentShown = ref(false)
const open = () =&gt; (isContentShown.value = true)

defineExpose({
  open
})
&lt;/script&gt;</code></pre><ul>
<li>MyModal 의 인스턴스 타입을 얻으려면 먼저 <code>typeof</code> 를 통해 타입을 가져온 다음 타입스크립트의 내장 </li>
<li><code>InstanceType</code> 유틸리티를 사용하여 인스턴스 타입을 추출해야 한다.</li>
</ul>
<pre><code>&lt;!-- App.vue --&gt;
&lt;script setup lang=&quot;ts&quot;&gt;
import MyModal from &#39;./MyModal.vue&#39;

const modal = ref&lt;InstanceType&lt;typeof MyModal&gt; | null&gt;(null)

const openModal = () =&gt; {
  modal.value?.open()
}
&lt;/script&gt;</code></pre><ol start="11">
<li>컴포넌트 v-model</li>
</ol>
<ul>
<li>기본적으로 컴포넌트의 v-model 은 modelValue 를 프로퍼티로, update:modelValue 를 이벤트로 사용</li>
<li>네이티브 <code>&lt;input&gt;</code> 앨리먼트의 <code>value</code> 속성을 <code>modelValue</code> 프로퍼티에 바인딩.</li>
<li>네이티브 <code>input</code> 이벤트가 트리거되면 새 값으로 <code>update:modelValue</code> 사용자 지정 이벤트를 내보낸다.</li>
</ul>
<pre><code>&lt;!-- CustomInput.vue --&gt;
&lt;script setup&gt;
defineProps([&#39;modelValue&#39;])
defineEmits([&#39;update:modelValue&#39;])
&lt;/script&gt;

&lt;template&gt;
  &lt;input
    :value=&quot;modelValue&quot;
    @input=&quot;$emit(&#39;update:modelValue&#39;, $event.target.value)&quot;
  /&gt;
&lt;/template&gt;</code></pre><pre><code>&lt;CustomInput v-model=&quot;searchText&quot; /&gt;</code></pre><ul>
<li>v-model arguments</li>
<li>v-model에 인자를 전달하여 이름 수정가능:</li>
</ul>
<pre><code>&lt;MyComponent v-model:title=&quot;bookTitle&quot; /&gt;</code></pre><pre><code>&lt;!-- MyComponent.vue --&gt;
&lt;script setup&gt;
defineProps([&#39;title&#39;])
defineEmits([&#39;update:title&#39;])
&lt;/script&gt;

&lt;template&gt;
  &lt;input
    type=&quot;text&quot;
    :value=&quot;title&quot;
    @input=&quot;$emit(&#39;update:title&#39;, $event.target.value)&quot;
  /&gt;
&lt;/template&gt;</code></pre><ul>
<li>v-model 수정자 처리하기</li>
<li>Form 양식 입력 바인딩에 대해 배울 때 v-model에 .trim, .number 및 .lazy와 같은 내장 수정자가 있다</li>
<li>v-model 컴포넌트에 추가되는 수정자는 modelModifiers 프로퍼티를 통해 컴포넌트에 제공</li>
<li>컴포넌트의 modelModifiers 프로퍼티에 capitalize 가 포함되어 있고 그 값은 v-model 바인딩 
v-model.capitalize=”myText”에 설정되어 있기 때문에 true 인 것을 알 수 있다.</li>
</ul>
<pre><code>&lt;MyComponent v-model.capitalize=&quot;myText&quot; /&gt;</code></pre><pre><code>&lt;script setup&gt;
const props = defineProps({
  modelValue: String,
  modelModifiers: { default: () =&gt; ({}) }
})

const emit = defineEmits([&#39;update:modelValue&#39;])
console.log(props.modelModifiers) // { capitalize: true }

function emitValue(e) {
  let value = e.target.value
  if (props.modelModifiers.capitalize) {
    value = value.charAt(0).toUpperCase() + value.slice(1)
  }
  emit(&#39;update:modelValue&#39;, value)
}
&lt;/script&gt;

&lt;template&gt;
  &lt;input type=&quot;text&quot; :value=&quot;modelValue&quot; @input=&quot;emitValue&quot; /&gt;
&lt;/template&gt;</code></pre></div>
<div class="btn-top"><a href="#header"><span class="blind">위로가기</span></a></div>
<script>
  let percentItems=[];
  let completeItems=[];
  let deleteItems=[];
  let totalValue=0;
  let doc = document;
  
    function getDocHeight() {
        return Math.max(
            doc.body.scrollHeight, doc.documentElement.scrollHeight,
            doc.body.offsetHeight, doc.documentElement.offsetHeight,
            doc.body.clientHeight, doc.documentElement.clientHeight
        );
     }
    function getWindowHeight() {
        return window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
    }
  let timer = setTimeout(function () {
        clearTimeout(timer);
        $('table a').attr('target', '_blank');
        let i=0;
        let titleVer=$('h1');
        let replaceTitle=titleVer.text()+'( ver 1.7.7 )';
        
        titleVer.text(replaceTitle);
        
        let titleMenus=$('h2');
        let len=titleMenus.length;
        
        let result='<div class="nav-bar"><div class="side-bar"><p class="tit">바로가기 메뉴</p>';
        for(i=0;i<len;i++){
          let txt=titleMenus.eq(i).text();
          let menuTxt=String(txt).replace(/^[0-9]+.s*/g, 'ㆍ ');
          let hashLink=titleMenus.eq(i).attr('id');
          result+='<a class="btn-shortcut" href="#'+hashLink+'" data-index="'+i+'">'+menuTxt+'</a>';
        }
        result+='</div><div class="m-bar"></div></div>';
        titleMenus.eq(0).before(result);
        $('.btn-top').on('click', function(e) {
          $('html,body').stop().animate({scrollTop:0}, 700 );
        });
        $('.m-bar').on('click', function(e){
          $('.side-bar').toggleClass('active');
          $('.m-bar').toggleClass('active');
        });
        let oldScrollNum=-1;
        let scrollSpyBtnItems=$('.btn-shortcut');
        scrollSpyBtnItems.on('click', function(e){
            let scrollIdx = $(this).attr('href');
             let offsetY=$(scrollIdx).offset().top;
             $('html, body').stop().animate({scrollTop:offsetY}, 350 );
             $('.side-bar').removeClass('active');
             $('.m-bar').removeClass('active');
            activeMenus( parseInt( $(this).attr('data-index')) );
        });
        scrollSpyBtnItems.on('mouseenter', function(e){
            $(window).off('scroll.body-scroll');
        });
        scrollSpyBtnItems.on('mouseleave', function(e){
            $(window).on('scroll.body-scroll', updateScrollSpy );
        });
        
        function activeMenus(idx){
            if( oldScrollNum===idx ){ return; }
            scrollSpyBtnItems.eq(idx).addClass('active').siblings().removeClass('active');
            oldScrollNum=idx;
        }
      
        let maxScroll= getDocHeight() - getWindowHeight();
        function updateScrollSpy(){
            let scrollTop=$(this).scrollTop();
            
            scrollSpyBtnItems.each(function(i, item){
                let scrollIdx = $(this).attr('href');
                let offsetY=$(scrollIdx).offset().top;
                let th=$(scrollIdx).outerHeight(true);
                //
                if(scrollTop>=offsetY && scrollTop<offsetY+th ){
                     activeMenus( i );
                }else{
                    if( maxScroll <= scrollTop ){
                        activeMenus( scrollSpyBtnItems.length-1 );
                    }
                }
            });
        }
        $(window).on('scroll.body-scroll', updateScrollSpy );
        activeMenus( 0 );
    }, 450 );//end setTimeout
</script>
</body></html>